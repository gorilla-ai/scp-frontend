{"version":3,"sources":["../../../src/utils/data-helper.js"],"names":["COMMON_VAR_TYPE","log","require","getLogger","_getValidator","type","_","includes","upperFirst","isArray","_isArrayOf","warn","ERROR","INVALID_ARGS","isNumber","array","isValid","forEach","elm","validate","length","every","el","isValidArgType","argument","validType","isString","isMatch","item","filter","id","data","group","match","isEmpty","convertRawDataToSymbolObj","selected","selectedProps","props","isBetween","time","interval","includeBoundary","offset","some","t"],"mappings":"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","sourcesContent":["/**\r\n * This file is for handling data-related issue, e.g,. convert gis input to {id, type, props...};\r\n * or validate the input data-type, e.g., validate the input is a String or not.\r\n *\r\n * @file   Functions related to data-handling.\r\n * @author Liszt\r\n */\r\n\r\nimport _ from 'lodash';\r\nimport moment from 'moment';\r\n\r\nimport { GIS_ERROR as ERROR } from './gis-exception';\r\n\r\nconst COMMON_VAR_TYPE = ['number', 'string', 'array', 'plainObject', 'function'];\r\n\r\nconst log = require('loglevel').getLogger('gis/utils/data-helper');\r\n\r\n\r\n/**\r\n * Gets the appropriate validator to check data type.\r\n *\r\n * @param {String | String[]} type   The validator's primitive type, which is 'number', 'string', 'array', 'plainObject', 'function', or an array.\r\n *\r\n * @return {Function}  A lodash method or a validation function.\r\n */\r\nfunction _getValidator(type) {\r\n  if (_.includes(COMMON_VAR_TYPE, type)) {\r\n    return _[`is${_.upperFirst(type)}`];\r\n  }\r\n\r\n  if (_.isArray(type)) {\r\n    return _isArrayOf;\r\n  }\r\n\r\n  log.warn(\r\n    ERROR.INVALID_ARGS,\r\n    type,\r\n    'Please input one of the following argument to check type. '\r\n    + '\\'number\\', \\'string\\', \\'array\\', \\'plainObject\\', \\'function\\''\r\n  );\r\n\r\n  // A default validator\r\n  return _.isNumber;\r\n}\r\n\r\n/**\r\n * Recursively checks the input data is array of target type, e.g., array of String.\r\n * It also handle the nested array.\r\n *\r\n * @param {type} array=[]   The input arguments are going to be validated.\r\n * @param {String} type     What's the primitive type of the array? E.g., Array of number.\r\n *\r\n * @return {Boolean}   Whether the input match the given primitive type?\r\n */\r\nfunction _isArrayOf(array = [], type) {\r\n  let isValid = false;\r\n\r\n  _.forEach(type, (elm) => {\r\n    const validate = _getValidator(elm);\r\n\r\n    isValid = array.length > 0\r\n      ? _.every(array, el => (_.isArray(elm) ? validate(el, elm) : validate(el)))\r\n      : false;\r\n\r\n    return !isValid;\r\n  });\r\n\r\n  return isValid;\r\n}\r\n\r\n/**\r\n * Checks arguments types.\r\n *\r\n * E.g., if there's a function foo(string/object/function *arg*), you can check arg's type with isValidArgType(arg, ['string', 'plainObject', 'function']).\r\n * Notice that type Object is written as 'plainObject' here.\r\n *\r\n * If you'd like to check *arg* is an array of specific primitive types, e.g. number[] or string[], you can check with isValidArgType(arg, [['number', 'string']]).\r\n * Notice that second parameter is a nested array. In this example, it will return true when the input is number[] or string[].\r\n *\r\n * @param {Number | Number[] | String | String[] | Object | Object[] | Function | Function[]} argument  The input arguments are going to be validated.\r\n * @param {String | String[]} [validType=['number', 'string', 'array', 'plainObject', 'function']]      What's the primitive type the argument should be?\r\n *\r\n * @return {Boolean}   Whether the argument match the given type?\r\n */\r\nexport function isValidArgType(argument, validType = COMMON_VAR_TYPE) {\r\n  let isValid = false;\r\n\r\n  if (_.isString(validType)) {\r\n    const validate = _getValidator(validType);\r\n    isValid = validate(argument);\r\n  } else if (_.isArray(validType)) {\r\n    _.forEach(validType, (el) => {\r\n      const validate = _getValidator(el);\r\n      isValid = _.isArray(el)\r\n        ? validate(argument, el)\r\n        : validate(argument);\r\n\r\n      return !isValid;\r\n    });\r\n  } else {\r\n    log.warn(ERROR.INVALID_ARGS, validType, 'The arguments should be (* argument, String/String[] validType?)');\r\n  }\r\n\r\n  return isValid;\r\n}\r\n\r\n/**\r\n * Checks if the global config, e.g., symbolOptions, should apply for the symbol.\r\n *\r\n * @param {Object} item                     The input arguments are going to be validated.\r\n * @param {Object} filter                   The filter used to validate the item.\r\n * @param {String | String[]} filter.id     The ids of symbols which should apply the global config.\r\n * @param {String | String[]} filter.type   The types of symbols which should apply the global config.\r\n * @param {Object} filter.data              The data of symbols which should apply the global config.\r\n * @param {String} filter.group             The group of symbols which should apply the global config.\r\n *\r\n * @return {Boolean}   Whether the item match the filter?\r\n */\r\nexport function isMatch(item, filter) {\r\n  const {\r\n    id,\r\n    type,\r\n    data,\r\n    group\r\n  } = filter;\r\n  const match = id === item.id\r\n        || (_.isArray(id) && _.includes(id, item.id))\r\n        || (type && type === item.type)\r\n        || (_.isArray(type) && _.includes(type, item.type))\r\n        || (!_.isEmpty(data) && _.isMatch(item.data, data))\r\n        || (group && group === item.group);\r\n\r\n  return match;\r\n}\r\n\r\n/**\r\n * Converts data to the format GIS can handle.\r\n *\r\n * @param {Object} item     The GIS raw data\r\n *\r\n * @return {Object}    The formatted GIS data\r\n */\r\nexport function convertRawDataToSymbolObj(item) {\r\n  const {\r\n    id,\r\n    type,\r\n    selected,\r\n    selectedProps,\r\n    ...props\r\n  } = item;\r\n\r\n  return {\r\n    id,\r\n    type,\r\n    selected,\r\n    selectedProps,\r\n    props\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if symbol's ts is within the GIS interval.\r\n *\r\n * @param {Number} time                     The timestamp of GIS.\r\n * @param {Number[]} interval               The GIS interval, which is [start, end].\r\n * @param {Boolean} [includeBoundary=true]  Should the interval contain the boundary?\r\n *\r\n * @return {Boolean}   Is the time within the interval?\r\n */\r\nexport function isBetween(time, interval, includeBoundary = true) {\r\n  const offset = includeBoundary ? 1 : 0;\r\n\r\n  if (_.isArray(time)) {\r\n    return _.some(time, t => (moment(t).isBetween(interval[0] - offset, interval[1] + offset)));\r\n  }\r\n\r\n  return moment(time).isBetween(interval[0] - offset, interval[1] + offset);\r\n}\r\n\r\nexport default {\r\n  isValidArgType,\r\n  isMatch,\r\n  isBetween,\r\n  convertRawDataToSymbolObj\r\n};\r\n"],"file":"data-helper.js"}