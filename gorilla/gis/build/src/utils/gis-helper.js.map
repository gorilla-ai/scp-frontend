{"version":3,"sources":["../../../src/utils/gis-helper.js"],"names":["log","require","getLogger","_getAllFeatures","geoJson","features","warn","ERROR","INVALID_ARGS","_","map","el","type","flattenDeep","getPathDistance","latlngs","crs","L","CRS","EPSG3857","length","reduce","acc","idx","clct","start","latLng","end","isArray","isPlainObject","distance","getCenterOfMass","symbol","latlng","featureGroup","SYMBOL_TYPE","GEOJSON","POLYGON","RECTANGLE","EXTRA_SYMBOL_TYPE","CLUSTER","layer","getBounds","getCenter","MARKER","SPOT","CIRCLE","props","POLYLINE","TRACK","Polyline","eachLayer","lyr","addLayer","INVALID_TYPE","values","isIntersect","symbolGeoJson","drawnGeoJson","intersect","some","feature","points","turf","lineIntersect","isOverlap","overlap","explode","inside","point","booleanPointInPolygon","convertCircleToPolygon","circle","vertices","startFrom","stopAt","_map","DOUBLE_PI","Math","PI","degreeToRadian","startAngle","stopAngle","options","isEPSG3857","radius","_radius","_mRadius","project","latLngToLayerPoint","bind","projection","unproject","layerPointToLatLng","projectedCentroid","_latlng","isStartLarger","stopRadian","startRadian","i","x","cos","y","sin","push","getLatLng","polygon","convertLatlngToMeters","lat1","lon1","lat2","lon2","d","geolib","getDistance","latitude","longitude","parseInt","convertMetersToLatLng","xOffset","yOffset","fromLat","fromLng","brng","atan","sqrt","result","computeDestinationPoint","lat","lng"],"mappings":"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","sourcesContent":["/**\r\n * This is for calculating geographic info or features\r\n * E.g., calculating the distance of input path(latlngs), or determine whether two svg-based feature intersect\r\n *\r\n * @file   Handles the GIS calculation, or processed GIS data\r\n * @author Liszt\r\n */\r\n\r\nimport _ from 'lodash'\r\nimport L from 'leaflet'\r\nimport * as turf from '@turf/turf'\r\nimport geolib from 'geolib'\r\n\r\nimport {GIS_ERROR as ERROR} from './gis-exception'\r\nimport {SYMBOL_TYPE, EXTRA_SYMBOL_TYPE} from '../consts/dictionary'\r\n\r\nlet log = require('loglevel').getLogger('gis/utils/gis-helper')\r\n\r\n/**\r\n * Fix issue #23. For getting all the features in nested feature collection\r\n *\r\n * @param {Object} geoJson  Geojson to be flatten\r\n *\r\n * @return {Object}    Flatten geojson\r\n */\r\nfunction _getAllFeatures(geoJson) {\r\n    if (!geoJson.features) {\r\n        log.warn(ERROR.INVALID_ARGS, geoJson, 'The argument should be a FeatureCollection')\r\n        return []\r\n    }\r\n\r\n    const features = _.map(geoJson.features, el => {\r\n        return el.type === 'FeatureCollection' ? _getAllFeatures(el) : el\r\n    })\r\n\r\n    return _.flattenDeep(features)\r\n}\r\n\r\n/**\r\n * Distance value varies due to the crs\r\n *\r\n * @link    https://leafletjs.com/reference-1.3.4.html#crs-l-crs-earth\r\n *\r\n * @param {LatLng[]} latlngs                The latlngs of a path. latlng should be [lat, lng] which lat & lng are numbers\r\n * @param {Object}   [crs=L.CRS.EPSG3857]   The CRS to be used in calculation. For CRS, see link above.\r\n *\r\n * @return {number}    The distance of the path\r\n */\r\nexport function getPathDistance(latlngs, crs=L.CRS.EPSG3857) {\r\n    if (latlngs.length <= 1) {\r\n        return 0\r\n    }\r\n    else {\r\n        return _.reduce(latlngs, (acc, el, idx, clct) => {\r\n            if (idx < clct.length - 1) {\r\n                let start = L.latLng(0, 0)\r\n                let end = L.latLng(0, 0)\r\n\r\n                if (_.isArray(el)) {\r\n                    start = L.latLng(el[0], el[1])\r\n                    end = L.latLng(clct[idx+1][0], clct[idx+1][1])\r\n                }\r\n                else if (_.isPlainObject(el)) {\r\n                    start = L.latLng(el)\r\n                    end = L.latLng(clct[idx+1])\r\n                }\r\n                else {\r\n                    log.warn(ERROR.INVALID_ARGS, el, 'Argument should be an array of number[lat, lng], or object{lat, lng}')\r\n                }\r\n\r\n                acc += crs.distance(start, end)\r\n            }\r\n\r\n            return acc\r\n        }, 0)\r\n    }\r\n}\r\n\r\n/**\r\n * Get a symbol's center of mass.\r\n *\r\n * @param {Symbol} symbol   The Symbol instance\r\n *\r\n * @return {LatLng}    Leaflet Latlng\r\n */\r\nexport function getCenterOfMass(symbol) {\r\n    let latlng = []\r\n    const featureGroup = L.featureGroup([])\r\n\r\n    switch (symbol.type) {\r\n        case SYMBOL_TYPE.GEOJSON:\r\n        case SYMBOL_TYPE.POLYGON:\r\n        case SYMBOL_TYPE.RECTANGLE:\r\n        case EXTRA_SYMBOL_TYPE.CLUSTER:\r\n            latlng = symbol.layer.getBounds().getCenter()\r\n            break\r\n\r\n        case SYMBOL_TYPE.MARKER:\r\n        case SYMBOL_TYPE.SPOT:\r\n        case SYMBOL_TYPE.CIRCLE:\r\n            latlng = symbol.props.latlng\r\n            break\r\n\r\n        // Polyline decorator don't support getBounds()\r\n        case SYMBOL_TYPE.POLYLINE:\r\n        case EXTRA_SYMBOL_TYPE.TRACK:\r\n            if (symbol.layer instanceof L.Polyline) {\r\n                latlng = symbol.layer.getCenter()\r\n            }\r\n            else {\r\n                symbol.layer.eachLayer(lyr => {\r\n                    (lyr instanceof L.Polyline) && featureGroup.addLayer(lyr)\r\n                })\r\n\r\n                latlng = featureGroup.getBounds().getCenter()\r\n            }\r\n            break\r\n\r\n        default:\r\n            log.warn(ERROR.INVALID_TYPE, symbol.type, `Please input valid types: ${_.values(SYMBOL_TYPE)}`)\r\n    }\r\n\r\n    return latlng\r\n}\r\n\r\n/**\r\n * Checks the geojson objects intersects or not. Used in region-selection plugins.\r\n *\r\n * @param {Object} symbolGeoJson    The GeoJson object of a Symbol on the map\r\n * @param {Object} drawnGeoJson     The GeoJson object of the drawn region on the map\r\n *\r\n * @return {Boolean}   The symbol and drawn region intersect or not\r\n */\r\nexport function isIntersect(symbolGeoJson, drawnGeoJson) {\r\n    // Convert symbol's geojson to geojson of points,\r\n    // then checking any one of them intersects the drawn region\r\n    const features = symbolGeoJson.type === 'FeatureCollection'\r\n                    ? _getAllFeatures(symbolGeoJson) // Fix issue #23\r\n                    : [symbolGeoJson]\r\n\r\n    const intersect = _.some(features, feature => {\r\n        const points = turf.lineIntersect(feature, drawnGeoJson)\r\n        return points.features.length > 0\r\n    })\r\n\r\n    return intersect\r\n}\r\n\r\n/**\r\n * Checks the geojson objects overlaps or not. Used in region-selection plugins.\r\n *\r\n * @param {Object} symbolGeoJson    The GeoJson object of a Symbol on the map\r\n * @param {Object} drawnGeoJson     The GeoJson object of the drawn region on the map\r\n *\r\n * @return {Boolean}   The symbol and drawn region overlap or not\r\n */\r\nexport function isOverlap(symbolGeoJson, drawnGeoJson) {\r\n    // Convert symbol's geojson to geojson of points,\r\n    // then checking any one of them is inside the drawn region\r\n    const features = symbolGeoJson.type === 'FeatureCollection'\r\n                    ? _getAllFeatures(symbolGeoJson)\r\n                    : [symbolGeoJson]\r\n\r\n    const overlap = _.some(features, feature => {\r\n        const points = turf.explode(feature)\r\n        const inside = _.some(points.features, point => {\r\n            return turf.booleanPointInPolygon(point, drawnGeoJson)\r\n        })\r\n\r\n        return inside\r\n    })\r\n\r\n    return overlap\r\n}\r\n\r\n/**\r\n * Checks the SVGs intersect or not. Used in region-selection plugins.\r\n * SVGGeometryElement.isPointInStroke() & SVGGeometryElement.isPointInFill () are only supported in Chrome by Aug, 2017\r\n *\r\n * @param {SVGElement} symbolSvg    The SVG element of a Symbol on the map.\r\n * @param {SVGElement} drawnSvg     The SVG element of the drawn region on the map\r\n *\r\n * @return {Boolean}   Two SVGs intersect or not.\r\n */\r\n// export function isSvgIntersect(symbolSvg, drawnSvg) {\r\n//     const drawnBBox = drawnSvg.getBBox(),\r\n//         symbolBBox = symbolSvg.getBBox()\r\n\r\n//     const drawnSize = drawnBBox.width * drawnBBox.height,\r\n//         symbolSize = symbolBBox.width * symbolBBox.height\r\n\r\n//     const svgA = drawnSize > symbolSize ? drawnSvg : symbolSvg,\r\n//         svgB = drawnSize > symbolSize ? symbolSvg : drawnSvg\r\n\r\n//     let intersect = false\r\n\r\n//     for (let i = 0; i < svgB.getTotalLength(); i++) {\r\n//         const point = svgB.getPointAtLength(i)\r\n//         if (svgA.isPointInStroke(point) || svgA.isPointInFill(point)) {\r\n//             intersect = true\r\n//             break\r\n//         }\r\n//     }\r\n\r\n//     return intersect\r\n// }\r\n\r\n/**\r\n * Support to convert semicircle to polygon. Fix issue #26.\r\n *\r\n * @param {L.Circle} circle                 L.Circle instance to be converted.\r\n * @param {L.Map}    map                    The container of the circle.\r\n * @param {Object}   [options]              Converting options.\r\n * @param {Number}   [options.vertices=180] Vertices amount of the ouput polygon.\r\n * @param {Number}   [options.startFrom=0]  Start angle of the semi-circle.\r\n * @param {Number}   [options.stopAt=360]   Stop angle of the scircle.\r\n *\r\n * @return {L.Polygon}     The ouput polygon.\r\n */\r\nexport function convertCircleToPolygon(circle, map, {vertices=180, startFrom=0, stopAt=360}) {\r\n    map = map || circle._map\r\n    if (!map) {\r\n        log.warn('Please create map before convert circle to polygon.')\r\n        return null\r\n    }\r\n\r\n    const DOUBLE_PI = 2 * Math.PI\r\n    const degreeToRadian = Math.PI / 180\r\n\r\n    // Normalize the angle\r\n    const startAngle = (startFrom % 360) < 0 ? (startFrom % 360) + 360 : startFrom\r\n    const stopAngle = (stopAt % 360) < 0 ? (stopAt % 360) + 360 : stopAt\r\n\r\n    const crs = map.options.crs\r\n    const isEPSG3857 = crs === L.CRS.EPSG3857\r\n\r\n    const radius = isEPSG3857 ? circle._radius : circle._mRadius\r\n\r\n    const project = isEPSG3857\r\n                    ? map.latLngToLayerPoint.bind(map)\r\n                    : crs.projection.project.bind(crs.projection)\r\n\r\n    const unproject = isEPSG3857\r\n                    ? map.layerPointToLatLng.bind(map)\r\n                    : crs.projection.unproject.bind(crs.projection)\r\n\r\n    const projectedCentroid = project(circle._latlng)\r\n\r\n    const points = []\r\n    const isStartLarger = startAngle > stopAngle\r\n\r\n    const stopRadian = isStartLarger ? (startAngle * degreeToRadian) : stopAngle * degreeToRadian\r\n    let startRadian = isStartLarger ? (stopAngle * degreeToRadian) : startAngle * degreeToRadian\r\n\r\n    for (let i = 0; i < vertices; i++) {\r\n        startRadian += (DOUBLE_PI / vertices)\r\n\r\n        if (startRadian <= stopRadian) {\r\n            const point = L.point(\r\n                projectedCentroid.x + (radius * Math.cos((Math.PI / 2) - startRadian)),\r\n                projectedCentroid.y + (radius * Math.sin((Math.PI / 2) - startRadian))\r\n            )\r\n\r\n            points.push(unproject(point))\r\n        }\r\n    }\r\n\r\n    // Specify the endpoint\r\n    if (startAngle !== 0 || stopAngle !== 360) {\r\n        points.push(circle.getLatLng())\r\n    }\r\n\r\n    return L.polygon(points)\r\n}\r\n\r\n/**\r\n * Gets the distance in meter between two geo points.\r\n *\r\n * @param {Number[]} start  Start latlng, formatted as [Number lat, Number lng]\r\n * @param {Number[]} end    End latlng, formatted as [Number lat, Number lng]\r\n *\r\n * @return {Number}    The distance in meter.\r\n */\r\nexport function convertLatlngToMeters([lat1, lon1], [lat2, lon2]) {\r\n    // generally used geo measurement function\r\n    const d = geolib.getDistance({latitude:lat1, longitude:lon1}, {latitude:lat2, longitude:lon2})\r\n    return parseInt(d, 10)\r\n}\r\n\r\n/**\r\n * Gets geo point from a start point and offset in meter.\r\n *\r\n * @param {Number[]} latlng     Start latlng, formatted as [Number lat, Number lng]\r\n * @param {Number}   xOffset    The x-offset in meter from the start point.\r\n * @param {Number}   yOffset    The y-offset in meter from the start point.\r\n *\r\n * @return {Number[]} - The calculated latlng.\r\n */\r\nexport function convertMetersToLatLng([fromLat, fromLng], xOffset, yOffset) {\r\n    const brng = Math.atan(yOffset/xOffset)*180/Math.PI\r\n    const d = Math.sqrt((yOffset*yOffset)+(xOffset*xOffset))\r\n    const result = geolib.computeDestinationPoint({lat:fromLat, lng:fromLng}, d, brng)\r\n    return [result.latitude, result.longitude]\r\n}\r\n\r\nexport default {\r\n    getPathDistance,\r\n    getCenterOfMass,\r\n    isIntersect,\r\n    // isSvgIntersect,\r\n    isOverlap,\r\n    convertCircleToPolygon,\r\n    convertLatlngToMeters,\r\n    convertMetersToLatLng\r\n}"],"file":"gis-helper.js"}