<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/events/netflow/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/events/netflow/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react'
import { withRouter } from 'react-router'
import PropTypes from 'prop-types'
import Moment from 'moment'
import _ from 'lodash'
import cx from 'classnames'
import queryString from 'query-string'

import {analyze} from 'vbda-ui/build/src/analyzer'
import Checkbox from 'react-ui/build/src/components/checkbox'
import {config as configLoader} from 'vbda-ui/build/src/loader'
import ContextMenu from 'react-ui/build/src/components/contextmenu'
import {downloadWithForm} from 'react-ui/build/src/utils/download'
import ModalDialog from 'react-ui/build/src/components/modal-dialog'
import PageNav from 'react-ui/build/src/components/page-nav'
import Popover from 'react-ui/build/src/components/popover'
import PopupDialog from 'react-ui/build/src/components/popup-dialog'
import Textarea from 'react-ui/build/src/components/textarea'

import {arrayMove} from 'react-sortable-hoc'
import {GithubPicker} from 'react-color';
import JSONTree from 'react-json-tree'

import helper from '../../common/helper'
import {HocQueryOpenSave as QueryOpenSave} from '../../common/query-open-save'
import {HocSearchOptions as SearchOptions} from '../../common/search-options'
import {HocSortableList as SortableList} from '../../common/sortable-list'
import {HocTableCell as TableCell} from '../../common/table-cell'
import withLocale from '../../../hoc/locale-provider'
import WORLDMAP from '../../../mock/world-map-low.json'

import Certification from './tabs/certification'
import Connections from './tabs/connections'
import Dns from './tabs/dns'
import Email from './tabs/email'
import File from './tabs/file'
import Ftp from './tabs/ftp'
import Html from './tabs/html'
import Http from './tabs/http'

import {default as ah, getInstance} from 'react-ui/build/src/utils/ajax-helper'

let t = null;
let f = null;
let et = null;

const ALL_TAB_DATA = {
  connections: 'Connections',
  dns: 'DNS',
  http: 'HTTP',
  html: 'HTML',
  email: 'Email',
  file: 'File',
  cert: 'Certification',
  ftp: 'FTP'
};

/**
 * Events Netflow
 * @class
 * @author Ryan Chen &lt;ryanchen@telmediatech.com>
 * @summary A react component to handle the business logic for the events page
 */
class Netflow extends Component {
  constructor(props) {
    super(props);

    t = chewbaccaI18n.getFixedT(null, 'connections');
    f = chewbaccaI18n.getFixedT(null, 'tableFields');
    et = chewbaccaI18n.getFixedT(null, 'errors');

    this.state = {
      projectID: '',
      activeTab: 'connections',
      //General
      datetime: {
        from: helper.getSubstractDate(1, 'hour'),
        to: Moment().local().format('YYYY-MM-DDTHH:mm:ss')
        //from: '2019-08-27T05:28:00Z',
        //to: '2019-08-27T05:29:00Z'
      },
      currentPage: 1,
      oldPage: 1,
      pageSize: 20,
      pageSizeGrid: 50,
      pageSizeMap: 500,
      sort: {
        field: 'lastPacket',
        desc: true
      },
      //Left nav
      searchTreeObj: {},
      treeRawData: {},
      treeData: {},
      currentTreeName: '',
      //Tab Menu
      subTabMenu: {
        table: t('txt-table'),
        linkAnalysis: t('txt-linkAnalysis'),
        worldMap: t('txt-map')
      },
      activeSubTab: 'table',
      //Search bar
      searchInput: {
        searchType: 'manual',
        searchInterval: '1h',
        refreshTime: '600000', //10 minutes
        inputManual: '',
        inputAuto: '',
      },
      //Events count
      eventsCount: {},
      //Connections
      connectionsChartType: 'connections',
      connectionsInterval: '1m',
      sessionHistogram: {},
      packageHistogram: {},
      byteHistogram: {},
      filterData: [{
        condition: 'must',
        query: ''
      }],
      //Sub sections
      subSectionsData: {
        mainData: {
          connections: [],
          dns: [],
          http: [],
          html: [],
          email: [],
          file: [],
          cert: [],
          ftp: []
        },
        fieldsData: {
          connections: {},
          dns: {},
          http: {},
          html: {},
          email: {},
          file: {},
          cert: {},
          ftp: {}
        },
        laData: {
          connections: []
        },
        mapData: {
          connections: []
        },
        tableColumns: {},
        totalCount: {
          connections: 0,
          dns: 0,
          http: 0,
          html: 0,
          email: 0,
          file: 0,
          cert: 0,
          ftp: 0
        }
      },
      LAconfig: {},
      mainEventsData: {},
      showImgCheckbox: false,
      displayType: 'list', //list, grid
      account: {
        id: '',
        login: false,
        fields: [],
        logsLocale: ''
      },
      sortedDataList: [],
      tagData: {
        id: '',
        projectID: '',
        sessionID: '',
        modalTitle: '',
        color: '#FCCB00',
        memo: ''
      },
      pcapData: {
        projectID: '',
        sessionID: '',
        origData: [],
        data: [],
        page: 1,
        pageSize: 10,
        totalCount: 0,
        activeIndex: null,
        hex: '',
        filterEmpty: false
      },
      queryData: {
        id: '',
        name: '',
        inputName: '',
        displayId: '',
        displayName: '',
        list: [],
        query: '',
        formattedQuery: '',
        openFlag: false
      },
      newQueryName: true,
      geoJson: {
        mapDataArr: [],
        attacksDataArr: []
      },
      showFilter: false,
      showChart: false,
      modalOpen: false,
      openQueryOpen: false,
      saveQueryOpen: false,
      taggingOpen: false,
      pcapOpen: false,
      tableMouseOver: false,
      currentTableIndex: '',
      currentLength: '',
      currentTableID: '',
      loadNetflowData: true,
      urlParams: {}
    };

    this.ah = getInstance('chewbacca');
  }
  componentDidMount() {
    const {session} = this.props;
    const {datetime, filterData, account} = this.state;
    let tempDatetime = {...datetime};
    let tempFilterData = {...filterData};
    let tempAccount = {...account};
    let urlParams = queryString.parse(location.search);

    if (session.accountId) {
      tempAccount.id = session.accountId;
      tempAccount.login = true;

      if (!_.isEmpty(urlParams)) {
        let ip = '';

        tempDatetime = {
          from: helper.getSubstractDate(30, 'minutes', urlParams.eventDttm),
          to: helper.getAdditionDate(30, 'minutes', urlParams.eventDttm)
        };

        if (urlParams.srcIp) {
          ip = 'ipSrc: ' + urlParams.srcIp;
        } else if (urlParams.destIp) {
          ip = 'ipDst: ' + urlParams.destIp;
        }

        tempFilterData = [{
          condition: 'must',
          query: ip
        }];
        urlParams = _.omit(urlParams, ['lng']);

        this.setState({
          datetime: tempDatetime,
          filterData: tempFilterData,
          account: tempAccount,
          showFilter: true,
          urlParams
        }, () => {
          this.initialLoad();
        });
      } else {
        this.setState({
          account: tempAccount
        }, () => {
          this.initialLoad();
        });
      }
    }
  }
  /**
   * Initial load for the page
   * @method
   * @param none
   * @returns none
   */
  initialLoad = () => {
    this.getLAconfig();
    this.getSavedQuery();
    this.getProjectId();
  }
  /**
   * Get and set the Link Analysis config
   * @method
   * @param none
   * @returns none
   */
  getLAconfig = () => {
    const {baseUrl} = this.props;

    helper.getLAconfig(baseUrl)
    .then(data => {
      if (!_.isEmpty(data)) {
        this.setState({
          LAconfig: configLoader.processAll(data)
        });
      }
      return null;
    });
  }
  /**
   * Get and set the account saved query
   * @method
   * @param none
   * @returns none
   */
  getSavedQuery = () => {
    const {baseUrl} = this.props;
    const {account, queryData} = this.state;

    helper.getSavedQuery(baseUrl, account, queryData, 'event')
    .then(data => {
      if (!_.isEmpty(data)) {
        this.setState({
          queryData: data
        });
      }
      return null;
    });
  }
  /**
   * Get and set the project ID
   * @method
   * @param none
   * @returns none
   */
  getProjectId = () => {
    const {baseUrl} = this.props;
    const url = `${baseUrl}/api/agent/_search`;
    const agentData = {
      pageSize: 10000
    };

    helper.getAjaxData('POST', url, agentData)
    .then(data => {
      if (data.rows.length > 0) {
        const projectID = data.rows.map(tempData => {
          return tempData.projectId;
        });

        this.setState({
          projectID
        }, () => {
          this.loadAllFields();
        });
      } else {
        helper.showPopupMsg(t('events.connections.txt-addAgentMsg'), '', '', '', 'agent');
      }
      return null;
    });
  }
  /**
   * Copy search fields into table columns
   * @method
   * @param none
   * @returns none
   */
  loadAllFields = () => {
    let tempSubSectionsData = {...this.state.subSectionsData};
    tempSubSectionsData.tableColumns = _.cloneDeep(this.props.searchFields);
    tempSubSectionsData.tableColumns.connections = tempSubSectionsData.tableColumns.session;
    tempSubSectionsData.tableColumns.file.push('base64');

    this.setState({
      subSectionsData: tempSubSectionsData
    }, () => {
      this.loadEventsCount('loadFields');
    });
  }
  /**
   * Get and set the events count
   * @method
   * @param {string} options - option for 'loadFields'
   * @returns none
   */
  loadEventsCount = (options) => {
    const {baseUrl} = this.props;
    const {projectID, eventsCount, activeTab} = this.state;
    const projectIDstring = this.getProjectURL(projectID);
    let apiArr = [];
    let tempEventsCount = {...eventsCount};

    _.forEach(ALL_TAB_DATA, (val, key) => {
      key = key === 'connections' ? 'session' : key;

      apiArr.push({
        url: `${baseUrl}/api/network/${key}/_search?${projectIDstring}&amp;page=1&amp;pageSize=10`,
        data: JSON.stringify(this.toQueryLanguage()),
        type: 'POST',
        contentType: 'text/plain'
      });
    })

    this.ah.all(apiArr)
    .then(data => {
      if (data) {
        let i = 0;

        _.forEach(ALL_TAB_DATA, (val, key) => {
          if (data[i]) {
            if (data[i].data) { //For Connections
              tempEventsCount[key] = data[i].data.counts;
            } else { //For all others
              tempEventsCount[key] = data[i].counts;
            }
          }
          i++;
        })

        this.setState({
          eventsCount: tempEventsCount
        }, () => {
          if (options === 'loadFields') {
            this.loadFields(activeTab);
          } else {
            if (activeTab === 'connections') {
              this.loadActiveSubTab(options);
            } else {
              this.loadSubSections(options);
            }
          }
        });
      }
      return null;
    })
    .catch(err => {
      helper.showPopupMsg('', t('txt-error'), err.message);
    })
  }
  /**
   * Get and set event fields of the account
   * @method
   * @param {string} activeTab - current tab
   * @param {string} options - options for 'showDefault' and 'noCount'
   * @returns none
   */
  loadFields = (activeTab, options) => {
    const {baseUrl} = this.props;
    const {subSectionsData, account} = this.state;
    let tempSubSectionsData = {...subSectionsData};
    let tempAccont = {...account};
    let url = '';
    let module = '';

    if (activeTab === 'connections') {
      module = 'FLOW_SESSION';
    } else {
      module = 'FLOW_' + activeTab.toUpperCase();
    }
    url = `${baseUrl}/api/account/flow/fields?module=${module}`;

    if (account.id &amp;&amp; account.login &amp;&amp; !options) {
      url += `&amp;accountId=${account.id}`;
    }

    this.ah.one({
      url,
      type: 'GET'
    })
    .then(data => {
      if (data.length > 0) {
        let filedsArr = [];

        data.unshift('_tableMenu_');

        _.forEach(data, val => {
          filedsArr.push(val);
        });

        //Filter out the columns that are not in the account fields
        const filterArr = _.remove(tempSubSectionsData.tableColumns[activeTab], item => {
          return _.indexOf(filedsArr, item) &lt; 0;
        });

        //Merge the account fields and all other fields
        tempSubSectionsData.tableColumns[activeTab] = _.concat(filedsArr, filterArr);
        tempAccont.fields = filedsArr;

        if (activeTab === 'file') {
          if (!_.includes(tempAccont.fields, 'base64')) {
            tempAccont.fields.push('base64');
          }
        }

        this.setState({
          subSectionsData: tempSubSectionsData,
          account: tempAccont
        }, () => {
          this.loadSection(options);
        });
      } else {
        this.loadFields(activeTab, 'showDefault');
      }
      return null;
    })
    .catch(err => {
      helper.showPopupMsg('', t('txt-error'), err.message);
    })
  }
  /**
   * Load subtab content ('table', 'link analysis' or 'world map')
   * @method
   * @param {string} options - option for 'search'
   * @returns none
   */
  loadActiveSubTab = (options) => {
    const {activeTab, activeSubTab} = this.state;

    if (activeSubTab === 'table') {
      if (activeTab === 'connections') {
        this.loadConnections(options);
      } else {
        this.loadSubSections(options);
      }
    } else if (activeSubTab === 'linkAnalysis') {
      this.resetLinkAnalysis(options);
    } else if (activeSubTab === 'worldMap') {
      this.loadWorldMap(options);
    }
  }
  /**
   * Hide certain columns for the table
   * @method
   * @param {string} field - field name
   * @returns true/false boolean
   */
  checkDisplayFields = (field) => {
    if (_.includes(this.state.account.fields, field) || field === '_tableMenu_') {
      return true;
    }
    return false;
  }
  /**
   * Load table data based on events type
   * @method
   * @param {string} options - option for 'noCount'
   * @returns none
   */
  loadSection = (options) => {
    const {activeTab} = this.state;

    if (!options || options !== 'noCount') {
      this.loadEventsCount();
    }

    if (activeTab === 'connections') {
      this.loadConnections();
    } else {
      this.loadSubSections();
    }
  }
  /**
   * Handle tab dropdown change
   * @method
   * @param {string} newTab - new tab to be loaded
   * @param {string} oldTab - old tab
   * @returns none
   */
  handleTabChange = (newTab, oldTab) => {
    const activeTab = newTab;
    const {subSectionsData, filterData, showFilter} = this.state;
    const fieldsData = this.props.searchFields;
    const fieldsDataObj = {
      connections: fieldsData.session,
      dns: fieldsData.dns,
      http: fieldsData.http,
      html: fieldsData.html,
      email: fieldsData.email,
      file: fieldsData.file,
      cert: fieldsData.cert,
      ftp: fieldsData.ftp
    };
    const defaultField = 'lastPacket';
    let tempSubSectionsData = {...subSectionsData};
    let tempFilterData = _.cloneDeep(filterData);
    let subTabMenu = {table: t('txt-table')};
    let activeSubTab = 'table';

    if (this.state.activeTab === newTab) {
      return;
    }

    if (activeTab === 'connections') {
      subTabMenu = {
        table: t('txt-table'),
        linkAnalysis: t('txt-linkAnalysis'),
        worldMap: t('txt-map')
      };
      activeSubTab = 'table';
    }

    if (showFilter) {
      for (var i = 0; i &lt; tempFilterData.length; i++) {
        tempFilterData[i].disabled = false;

        if (fieldsDataObj[activeTab].indexOf(tempFilterData[i].fields) &lt; 0) { //Item is not found in an array
          tempFilterData[i].disabled = true;
        }
      }
    } else {
      tempFilterData = [{
        condition: 'must',
        query: ''
      }];
    }

    tempSubSectionsData.mainData = {
      connections: [],
      dns: [],
      http: [],
      html: [],
      email: [],
      file: [],
      cert: [],
      ftp: [],
      logs: []
    };

    this.setState({
      activeTab,
      currentPage: 1,
      oldPage: 1,
      pageSize: 20,
      pageSizeGrid: 50,
      pageSizeMap: 500,
      subTabMenu,
      activeSubTab,
      sort: {
        field: defaultField,
        desc: true
      },
      filterData: tempFilterData,
      subSectionsData: tempSubSectionsData,
      treeRawData: {},
      treeData: {},
      showImgCheckbox: false,
      displayType: 'list',
      showChart: false,
      tableMouseOver: false
    }, () => {
      this.loadFields(activeTab, 'noCount');
    });
  }
  /**
   * Construct project URL
   * @method
   * @param {string} projectID - project ID
   * @returns project URL
   */
  getProjectURL = (projectID) => {
    let projectIDstring = '';

    if (_.isArray(projectID)) {
      _.forEach(projectID, id => {
        projectIDstring += 'projectId=' + id + '&amp;';
      });
    } else {
      projectIDstring = 'projectId=' + projectID + '&amp;';
    }

    return projectIDstring.slice(0, -1);
  }
  /**
   * Check table sort
   * @method
   * @param {string} field - table field name
   * @returns true for sortable or null
   */
  checkSortable = (field) => {
    const unSortableFields = ['_tableMenu_', 'base64', 'filePath', 'controlText', 'htmlRelinkPath', 'body', 'requestRawHeader', 'responseRawHeader', 'uploadData', 'dnsho'];

    if (_.includes(unSortableFields, field)) {
      return null;
    } else {
      return true;
    }
  }
  /**
   * Load Connections data
   * @method
   * @param {string} options - option for 'search'
   * @returns none
   */
  loadConnections = (options) => {
    const {baseUrl, contextRoot} = this.props;
    const {projectID, connectionsInterval, currentPage, oldPage, pageSize, subSectionsData, account} = this.state;
    const projectIDstring = this.getProjectURL(projectID);
    const setPage = options === 'search' ? 1 : currentPage;

    this.ah.all([{
      url: `${baseUrl}/api/network/session/_search?${projectIDstring}&amp;interval=${connectionsInterval}&amp;page=${setPage}&amp;pageSize=${pageSize}&amp;accountId=${account.id}&amp;showTag=Y&amp;appendIpInfo=true`,
      data: JSON.stringify(this.toQueryLanguage(options)),
      type: 'POST',
      contentType: 'text/plain'
    },
    {
      url: `${baseUrl}/api/network/session/service/_aggregate?${projectIDstring}`,
      data: JSON.stringify(this.toQueryLanguage('time')),
      type: 'POST',
      contentType: 'text/plain'
    }])
    .then(data => {
      if (currentPage > 1 &amp;&amp; !data[0]) {
        helper.showPopupMsg('', t('txt-error'), t('events.connections.txt-maxDataMsg'));

        this.setState({
          currentPage: oldPage
        });
        return;
      }

      if (_.isEmpty(data[0]) || data[0].data.counts === 0) {
        helper.showPopupMsg(t('txt-notFound', ''));

        let tempSubSectionsData = {...this.state.subSectionsData};
        tempSubSectionsData.mainData.connections = [];
        tempSubSectionsData.laData.connections = [];
        tempSubSectionsData.mapData.connections = [];
        tempSubSectionsData.totalCount.connections = 0;

        this.setState({
          subSectionsData: tempSubSectionsData,
          connectionsChartType: 'connections',
          connectionsInterval: '1m',
          sessionHistogram: {},
          packageHistogram: {},
          byteHistogram: {},
          currentPage: 1,
          oldPage: 1,
          pageSize: 20,
          treeRawData: {},
          treeData: {}
        });
        return;
      }

      const tempArray = data[0].data.rows.map(tempData => {
        tempData.content.id = tempData.id;

        if (tempData.tag) {
          tempData.content.tag = tempData.tag;
        }

        return tempData.content;
      });

      const currentLength = data[0].data.rows.length &lt; pageSize ? data[0].data.rows.length : pageSize;

      let tempFields = {};
      subSectionsData.tableColumns.connections.forEach(tempData => {
        tempFields[tempData] = {
          hide: !this.checkDisplayFields(tempData),
          label: f(`connectionsFields.${tempData}`),
          sortable: this.checkSortable(tempData),
          formatter: (value, allValue, i) => {
            if (tempData === '_tableMenu_') {
              return (
                &lt;div className={cx('table-menu', {'active': value})}>
                  &lt;button onClick={this.handleRowContextMenu.bind(this, allValue)}>&lt;i className='fg fg-more'>&lt;/i>&lt;/button>
                &lt;/div>
              )
            }
            if (tempData === 'firstPacket' || tempData === 'lastPacket' || tempData === '_eventDttm_') {
              value = helper.getFormattedDate(value, 'local');
            }
            return (
              &lt;TableCell
                baseUrl={baseUrl}
                contextRoot={contextRoot}
                fieldValue={value}
                fieldName={tempData}
                allValue={allValue}
                showQueryOptions={this.showQueryOptions} />
            )
          }
        }
      })

      const treeObj = this.getTreeData(data[1]);
      let tempSubSectionsData = {...subSectionsData};
      tempSubSectionsData.mainData.connections = tempArray;
      tempSubSectionsData.fieldsData.connections = tempFields;
      tempSubSectionsData.mapData.connections = data[0].data.rows;
      tempSubSectionsData.totalCount.connections = data[0].data.counts;

      const tempCurrentPage = options === 'search' ? 1 : currentPage;
      const dataArray = tempSubSectionsData.mainData.connections;

      for (var i = 0; i &lt; dataArray.length; i++) {
        for (var key in dataArray[i]) {
          if (Array.isArray(dataArray[i][key])) {
            tempSubSectionsData.mainData.connections[i][key] = helper.arrayDataJoin(dataArray[i][key], '', ', ');
          }
        }
      }

      this.setState({
        currentPage: tempCurrentPage,
        oldPage: tempCurrentPage,
        subSectionsData: tempSubSectionsData,
        treeRawData: data[1],
        treeData: treeObj,
        searchTreeObj: treeObj,
        sessionHistogram: data[0].sessionHistogram,
        packageHistogram: data[0].packageHistogram,
        byteHistogram: data[0].byteHistogram,
        currentLength
      });
    })
    .catch(err => {
      helper.showPopupMsg('', t('txt-error'), err.message);
    })
  }
  /**
   * Load events data other than Connections (DNS, File, Email, HTTP, etc.)
   * @method
   * @param {string} options - option for 'search'
   * @returns none
   */
  loadSubSections = (options) => {
    const {baseUrl, contextRoot} = this.props;
    const {projectID, activeTab, currentPage, oldPage, pageSize, pageSizeGrid, subSectionsData, account} = this.state;
    const projectIDstring = this.getProjectURL(projectID);
    const setPage = options === 'search' ? 1 : currentPage;
    const isFileGrid = this.fileImageGrid();
    const pageSizeSet = isFileGrid ? pageSizeGrid : pageSize;

    this.ah.all([{
      url: `${baseUrl}/api/network/${activeTab}/_search?${projectIDstring}&amp;page=${setPage}&amp;pageSize=${pageSizeSet}&amp;accountId=${account.id}&amp;showTag=Y`,
      data: JSON.stringify(this.toQueryLanguage(options)),
      type: 'POST',
      contentType: 'text/plain'
    },
    {
      url: `${baseUrl}/api/network/${activeTab}/service/_aggregate?${projectIDstring}`,
      data: JSON.stringify(this.toQueryLanguage('time')),
      type: 'POST',
      contentType: 'text/plain'
    }])
    .then(data => {
      if (currentPage > 1 &amp;&amp; data[0].rows.length === 0) {
        helper.showPopupMsg('', t('txt-error'), t('events.connections.txt-maxDataMsg'));

        this.setState({
          currentPage: oldPage
        });
        return;
      }

      let tempSubSectionsData = {...subSectionsData};

      if (_.isEmpty(data[0]) || data[0].counts === 0) {
        helper.showPopupMsg(t('txt-notFound', ''));

        let tempSubSectionsData = {...this.state.subSectionsData};
        tempSubSectionsData.mainData[activeTab] = [];
        tempSubSectionsData.totalCount[activeTab] = 0;
        tempSubSectionsData.laData[activeTab] = [];
        tempSubSectionsData.mapData[activeTab] = [];

        const resetObj = {
          subSectionsData: tempSubSectionsData,
          currentPage: 1,
          oldPage: 1,
          pageSize: 20
        };

        this.setState({
          ...resetObj,
          treeRawData: {},
          treeData: {}
        });
        return;
      }

      const tempArray = data[0].rows.map(tempData => {
        if (activeTab === 'dns') {
          tempData.content.id = tempData.id;
        } else {
          tempData.content.id = tempData.content.sessionId;
        }

        if (tempData.tag) {
          tempData.content.tag = tempData.tag;
        }

        return tempData.content;
      });

      const currentLength = data[0].rows.length &lt; pageSize ? data[0].rows.length : pageSize;

      let tempFields = {};
      subSectionsData.tableColumns[activeTab].forEach(tempData => {
        let tempFieldName = tempData;

        tempFields[tempData] = {
          hide: !this.checkDisplayFields(tempData),
          label: f(`${activeTab}Fields.${tempFieldName}`),
          sortable: this.checkSortable(tempData),
          formatter: (value, allValue) => {
            if (tempData === '_tableMenu_') {
              return (
                &lt;div className={cx('table-menu', {'active': value})}>
                  &lt;button onClick={this.handleRowContextMenu.bind(this, allValue)}>&lt;i className='fg fg-more'>&lt;/i>&lt;/button>
                &lt;/div>
              )
            }
            if (tempData === 'base64' &amp;&amp; value) {
              if (value.indexOf('data:image/') >= 0) {
                return &lt;img src={value} className='file-image' onClick={this.openImageModal(value)} />
              }
            } else if (tempData === 'filePath') {
              return &lt;a href={baseUrl + contextRoot + '/api/network/file?path=' + value} download>{value}&lt;/a>
            } else if (tempData === 'controlText') {
              return &lt;span title={value} onClick={this.showQueryOptions(tempData, value)}>{value.substr(0, 50) + '...'}&lt;/span>
            } else if (tempData === 'htmlRelinkPath') {
              return &lt;span className='file-html' onClick={this.openHTMLModal.bind(this, value)}>{value}&lt;/span>
            } else {
              if (tempData === 'firstPacket' || tempData === 'lastPacket' || tempData === '_eventDttm_') {
                value = helper.getFormattedDate(value, 'local');
              }
              return (
                &lt;TableCell
                  baseUrl={baseUrl}
                  contextRoot={contextRoot}
                  activeTab={activeTab}
                  fieldValue={value}
                  fieldName={tempData}
                  allValue={allValue}
                  showQueryOptions={this.showQueryOptions} />
              )
            }
          }
        };
      })

      const treeObj = this.getTreeData(data[1]);
      tempSubSectionsData.totalCount[activeTab] = data[0].counts;
      tempSubSectionsData.mainData[activeTab] = tempArray;
      tempSubSectionsData.fieldsData[activeTab] = tempFields;

      const tempCurrentPage = options === 'search' ? 1 : currentPage;
      let dataArray = tempSubSectionsData.mainData[activeTab];
      let objectKey = '';

      if (activeTab === 'dns' || activeTab === 'email' || activeTab === 'ftp') {
        if (activeTab === 'email') {
          objectKey = 'emailAddress';
        } else if (activeTab === 'ftp') {
          objectKey = 'text';
        }

        for (var i = 0; i &lt; dataArray.length; i++) {
          for (var key in dataArray[i]) {
            let arraySeparator = ', ';

            if (Array.isArray(dataArray[i][key])) {
              if (key === 'controlText') {
                arraySeparator = ' ';
              }
              tempSubSectionsData.mainData[activeTab][i][key] = helper.arrayDataJoin(dataArray[i][key], objectKey, arraySeparator);
            }
          }
        }
      }

      this.setState({
        currentPage: tempCurrentPage,
        oldPage: tempCurrentPage,
        treeRawData: data[1],
        treeData: treeObj,
        subSectionsData: tempSubSectionsData,
        currentLength
      });
      return null;
    })
    .catch(err => {
      helper.showPopupMsg('', t('txt-error'), err.message);
    })
  }
  /**
   * Reset link analysis data to avoid weird display in LA
   * @method
   * @param {string} options - option for 'search'
   * @returns none
   */
  resetLinkAnalysis = (options) => {
    const {activeTab, subSectionsData} = this.state;
    let tempSubSectionsData = {...subSectionsData};
    tempSubSectionsData.laData[activeTab] = '';

    this.setState({
      subSectionsData: tempSubSectionsData
    }, () => {
      this.loadLinkAnalysis(options);
    });
  }
  /**
   * Get and set link analysis data
   * @method
   * @param {string} options - option for 'search'
   * @returns none
   */
  loadLinkAnalysis = (options) => {
    const {baseUrl, contextRoot} = this.props;
    const {activeTab, projectID, currentPage, pageSizeMap, subSectionsData, LAconfig} = this.state;
    const projectIDstring = this.getProjectURL(projectID); 
    const setPage = options === 'search' ? 1 : currentPage;
    const url = `${baseUrl}/api/network/session/la/_search?${projectIDstring}&amp;page=${setPage}&amp;pageSize=${pageSizeMap}`;
    const requestData = this.toQueryLanguage(options);
    let tempSubSectionsData = {...subSectionsData};
    let mainEventsData = {};

    helper.getAjaxData('POST', url, requestData)
    .then(data => {
      let laData = [];

      if (data.rows) {
        laData = data.rows;

        _.forEach(laData, val => {
          mainEventsData[val.id] = val.content;
        })

        tempSubSectionsData.laData[activeTab] = analyze(mainEventsData, LAconfig, {analyzeGis: false});
        tempSubSectionsData.totalCount[activeTab] = laData.counts;
      } else {
        helper.showPopupMsg(t('txt-notFound', ''));
        return;
      }

      this.setState({
        mainEventsData,
        subSectionsData: tempSubSectionsData
      });
    });
  }
  /**
   * Get and set data for the world map
   * @method
   * @param {string} options - option for 'search'
   * @returns none
   */
  loadWorldMap = (options) => {
    const {baseUrl, contextRoot} = this.props;
    const {activeTab, projectID, datetime, subSectionsData, currentPage, pageSizeMap} = this.state;
    const projectIDstring = this.getProjectURL(projectID);
    const setPage = options === 'search' ? 1 : currentPage;
    const url = `${baseUrl}/api/network/session/map/_search?${projectIDstring}&amp;page=${setPage}&amp;pageSize=${pageSizeMap}`;
    const requestData = this.toQueryLanguage();
    let tempSubSectionsData = {...subSectionsData};

    helper.getAjaxData('POST', url, requestData)
    .then(data => {
      const tempArray = _.map(data.rows, val => {
        val.content.id = val.id;
        return val.content;
      });

      tempSubSectionsData.mapData[activeTab] = tempArray;
      tempSubSectionsData.totalCount[activeTab] = data.counts;

      this.setState({
        subSectionsData: tempSubSectionsData
      }, () => {
        this.getWorldMap();
      });
    });
  }
  /**
   * Get and set world map geoJson data
   * @method
   * @param none
   * @returns none
   */
  getWorldMap = () => {
    const {activeTab, geoJson, subSectionsData} = this.state;

    this.setState({
      activeSubTab: 'worldMap',
      geoJson: helper.getWorldMap(WORLDMAP, geoJson, subSectionsData.mapData[activeTab])
    });
  }
  /**
   * Construct the netflow events api request body
   * @method
   * @param {string} options - option for 'search'
   * @returns requst data object
   */
  toQueryLanguage = (options) => {
    const {datetime, sort, filterData} = this.state;
    const timeAttribute = 'lastPacket';
    let time = {};
    let dateFrom = datetime.from;
    let dateTo = datetime.to;
    let dateTime = {};
    let dataObj = {};
    let filterDataArr = [];
    let sortObj = {};

    dateTime = {
      from: Moment(dateFrom).utc().format('YYYY-MM-DDTHH:mm:ss') + 'Z',
      to: Moment(dateTo).utc().format('YYYY-MM-DDTHH:mm:ss') + 'Z'
    };

    time[timeAttribute] = {
      op: 'BETWEEN',
      arg: [dateTime.from, dateTime.to]
    };

    if (options === 'time') {
      return time;
    }

    dataObj[timeAttribute] = time[timeAttribute];
    sortObj[sort.field] = sort.desc ? 'desc' : 'asc';

    if (options === 'images') {
      dataObj['detectedType'] = {
        op: 'LIKE',
        arg: 'image'
      };
    } else {
      if (filterData.length > 0) {
        filterDataArr = helper.buildFilterDataArray(filterData);
      }
    }

    if (filterDataArr.length > 0) {
      dataObj['filter'] = filterDataArr;
    }

    const dataOptions = {
      query: dataObj,
      sort: [sortObj]
    };

    return dataOptions;
  }
  /**
   * Set the netflow events tree data
   * @method
   * @param {string} value - tree node name
   * @returns none
   */
  showTreeFilterBtn = (value) => {
    this.setState({
      currentTreeName: value,
      treeData: this.getTreeData(this.state.treeRawData, value)
    });
  }
  /**
   * Set the netflow tree data
   * @method
   * @param {string} treeData - alert tree data
   * @param {string} treeName - tree node name
   * @returns tree data object
   */
  getTreeData = (treeData, treeName) => {
    const currentTreeName = treeName ? treeName : this.state.currentTreeName;
    let treeObj = { //Handle service tree data
      id: 'all',
      children: []
    };
    let allServiceCount = 0;

    _.keys(treeData)
    .sort()
    .forEach(key => {
      let tempChild = [];
      let label = '';
      let totalHostCount = 0;

      if (key) {
        treeData[key].forEach(key2 => {
          _.forEach(key2, (val, key3) => {
            let hostCount = 0;

            _.forEach(val, val2 => {
              hostCount += val2.counts;
            })

            totalHostCount += hostCount;

            label = &lt;span title={key3}>{key3} ({hostCount}) &lt;button className={cx('button', {'active': currentTreeName === key3})} onClick={this.selectTree.bind(this, key3, 'dstHostname')}>{t('events.connections.txt-addFilter')}&lt;/button>&lt;/span>;

            tempChild.push({
              id: key3,
              label
            });
          })
        })

        if (key === 'unknown') { //Add an export button for Unknown service
          label = &lt;span title={key}>{key} ({totalHostCount}) &lt;button className='button active' onClick={this.handleTreeExport}>{t('txt-export')}&lt;/button> &lt;button className={cx('button', {'active': currentTreeName === key})} onClick={this.selectTree.bind(this, key, 'dstSvcname')}>{t('events.connections.txt-addFilter')}&lt;/button>&lt;/span>;
        } else {
          let formattedKey = key;

          if (key.length > 25) {
            formattedKey = key.substr(0, 28) + '...';
          }
          label = &lt;span title={key}>{formattedKey} ({totalHostCount}) &lt;button className={cx('button', {'active': currentTreeName === key})} onClick={this.selectTree.bind(this, key, 'dstSvcname')}>{t('events.connections.txt-addFilter')}&lt;/button>&lt;/span>;
        }

        let treeProperty = {
          id: key,
          label
        };

        if (tempChild.length > 0) {
          treeProperty.children = tempChild;
        }

        treeObj.children.push(treeProperty);
        allServiceCount += totalHostCount;
      }
    })

    treeObj.label = t('txt-all') + ' (' + allServiceCount + ')';

    return treeObj;
  }
  /**
   * Handle tree export button
   * @method
   * @param none
   * @returns none
   */
  handleTreeExport = () => {
    const {baseUrl, contextRoot} = this.props;
    const {projectID, activeTab} = this.state;
    const type = activeTab === 'connections' ? 'session' : activeTab;
    const projectIDstring = this.getProjectURL(projectID);
    const url = `${baseUrl}${contextRoot}/api/network/${type}/service/unknown/_export?${projectIDstring}`;
    const dataOptions = {
      ...this.toQueryLanguage()
    };

    downloadWithForm(url, {payload: JSON.stringify(dataOptions)});
  }
  /**
   * Handle alert search submit
   * @method
   * @param {string} fromSearch - option for 'search'
   * @returns none
   */
  handleSearchSubmit = (fromSearch) => {
    const {activeTab, subSectionsData} = this.state;
    let tempSubSectionsData = {...subSectionsData};
    tempSubSectionsData.mainData[activeTab] = [];

    this.setState({
      subSectionsData: tempSubSectionsData
    }, () => {
      if (fromSearch) {
        this.setState({
          currentPage: 1,
          oldPage: 1,
          tableMouseOver: false
        }, () => {
          this.loadEventsCount(fromSearch);
        });
      }
    });
  }
  /**
   * Handle alert search reset
   * @method
   * @param {string} type - reset type ('filter' or 'mark')
   * @returns none
   */
  handleResetBtn = (type) => {
    const filterData = [{
      condition: 'must',
      query: ''
    }];
    let tempQueryData = {...this.state.queryData};
    tempQueryData.displayId = '';
    tempQueryData.displayName = '';
    tempQueryData.openFlag = false;

    this.setState({
      filterData,
      queryData: tempQueryData
    });
  }
  /**
   * Handle pagination change for LA and World Map
   * @method
   * @param {number} type - content type ('la' or 'map')
   * @param {number} currentPage - current page
   * @returns none
   */
  handleLargePageChange = (type, currentPage) => {
    this.setState({
      currentPage
    }, () => {
      if (type === 'la') {
        this.resetLinkAnalysis();
      } else if (type === 'map') {
        this.loadWorldMap();
      }
    });
  }
  /**
   * Handle page size dropdown for LA and World Map
   * @method
   * @param {number} type - content type ('la' or 'map')
   * @param {string} pageSize - current page size
   * @returns none
   */
  handleLargePageDropdown = (type, pageSize) => {
    this.setState({
      currentPage: 1,
      pageSizeMap: Number(pageSize)
    }, () => {
      if (type === 'la') {
        this.resetLinkAnalysis();
      } else if (type === 'map') {
        this.loadWorldMap();
      }
    });
  }
  /**
   * Handle pagination change
   * @method
   * @param {number} currentPage - current page
   * @returns none
   */
  handlePaginationChange = (currentPage) => {
    const {activeTab, showImgCheckbox} = this.state;

    this.setState({
      currentPage
    }, () => {
      if (activeTab === 'connections') {
        this.loadConnections();
      } else {
        this.loadSubSections(showImgCheckbox ? 'images' : '');
      }
    });
  }
  /**
   * Handle page size dropdown
   * @method
   * @param {string} pageSize - current page size
   * @returns none
   */
  handlePageDropdown = (pageSize) => {
    const {activeTab} = this.state;
    const isFileGrid = this.fileImageGrid();

    if (isFileGrid) {
      this.setState({
        currentPage: 1,
        pageSizeGrid: Number(pageSize)
      }, () => {
        this.loadSubSections('images');
      });
    } else {
      this.setState({
        currentPage: 1,
        pageSize: Number(pageSize)
      }, () => {
        if (activeTab === 'connections') {
          this.loadConnections();
        } else {
          this.loadSubSections();
        }
      });
    }
  }
  /**
   * Handle table sort
   * @method
   * @param {object} sort - sort data object
   * @returns none
   */
  handleTableSort = (sort) => {
    let tempSort = {...this.state.sort};
    tempSort.field = sort.field;
    tempSort.desc = sort.desc;

    this.setState({
      sort: tempSort
    }, () => {
      this.loadSection();
    });
  }
  /**
   * Handle tree filter button selection
   * @method
   * @param {string} value - selected node name
   * @param {string} field - corresponding field of selected node
   * @returns none
   */
  selectTree = (value, field) => {
    this.setState({
      loadNetflowData: false
    }, () => {
      this.addSearch(field, value, 'must');
    });
  }
  /**
   * Handle table menu PCAP download
   * @method
   * @param {string} value - table selected row data
   * @returns none
   */
  pcapDownloadFile = (value) => {
    const {baseUrl} = this.props;
    const projectId = value.projectName;
    const url = `${baseUrl}/api/network/session/pcapFile`;
    const data = {
      ro : (value.id || value.sessionId),
      _id : '',
      projectId : projectId
    };

    helper.getAjaxData('POST', url, data)
    .then(data => {
      if (data.ResultMessage === 'fail') {
        helper.showPopupMsg(t('txt-pcapDownloadFail'), t('txt-error'), data.ErrorMessage);
      } else {
        window.location.assign(data.PcapFilelink);
      }
    });    
  }
  /**
   * Handle table row mouse over to show menu button and tag memo
   * @method
   * @param {number} id - ID of the selected raw data
   * @param {object} allValue - table data
   * @param {object} evt - MouseoverEvents
   * @returns none
   */
  handleRowMouseOver = (id, allValue, evt) => {
    const {activeTab, subSectionsData} = this.state;
    let tempSubSectionsData = {...subSectionsData};
    tempSubSectionsData.mainData[activeTab] = _.map(tempSubSectionsData.mainData[activeTab], item => {
      return {
        ...item,
        _tableMenu_: allValue.id === item.id ? true : false
      };
    });

    this.setState({
      subSectionsData: tempSubSectionsData,
      tableMouseOver: true
    });

    if (allValue.tag &amp;&amp; allValue.tag.memo) {
      Popover.openId(
        'popup-id',
        evt,
        allValue.tag.memo
      )
    }
  }
  /**
   * Handle table row mouse out
   * @method
   * @param {number} id - ID of the selected raw data
   * @param {object} allValue - table data
   * @param {object} evt - MouseoverEvents
   * @returns none
   */
  handleRowMouseOut = (id, allValue, evt) => {
    Popover.closeId('popup-id')
  }
  /**
   * Construct and display table context menu
   * @method
   * @param {object} allValue - syslog data
   * @param {object} evt - mouseClick events
   * @returns none
   */
  handleRowContextMenu = (allValue, evt) => {
    this.handleRowMouseOut();

    const {activeTab} = this.state;
    const id = allValue.id;
    let menuItems = [];

    menuItems = [
      {
        id: id + 'Table',
        text: t('events.connections.txt-fieldsSettings'),
        action: () => this.showTableData(allValue)
      },
      {
        id: id + 'Json',
        text: t('events.connections.txt-viewJSON'),
        action: () => this.viewJsonData(allValue)
      }
    ];

    if (activeTab === 'connections') {
      menuItems.unshift(
        {
          id: id + 'downloadPCAP',
          text: t('events.connections.txt-downloadPCAP'),
          action: () => this.pcapDownloadFile(allValue)
        },
        {
          id: id + 'viewPCAP',
          text: t('events.connections.txt-viewPCAP'),
          action: () => this.getPCAPcontent(allValue)
        }
      );
    }

    if (allValue.tag) {
      menuItems.push(
        {
          id: id + 'EditTag',
          text: t('events.connections.txt-editTag'),
          action: () => this.addTagging(allValue)
        },
        {
          id: id + 'DeleteTag',
          text: t('events.connections.txt-deleteTag'),
          action: () => this.deleteTagging(allValue.tag.id)
        }
      );
    } else {
      if (allValue.vpnName) { //Disable the Add Tagging for Honeypot
        menuItems.push(
          {
            className: 'disabled-tag-menu',
            text: t('events.connections.txt-addTag'),
            action: () => { return; }
          }
        );
      } else {
        menuItems.push(
          {
            id: id + 'AddTag',
            text: t('events.connections.txt-addTag'),
            action: () => this.addTagging(allValue)
          }
        );
      }
    }

    ContextMenu.open(evt, menuItems, 'networkViewMenu');
    evt.stopPropagation();
  }
  /**
   * Show query option when click on the table raw filter icon
   * @method
   * @param {string} field - field name of selected field
   * @param {string | number} value - value of selected field
   * @param {object} e - mouseClick events
   * @returns none
   */
  showQueryOptions = (field, value) => (e) => {
    const menuItems = [
      {
        id: value + '_Must',
        text: 'Must',
        action: () => this.addSearch(field, value, 'must')
      },
      {
        id: value + '_MustNot',
        text: 'Must Not',
        action: () => this.addSearch(field, value, 'must_not')
      },
      {
        id: value + '_Either',
        text: 'Either',
        action: () => this.addSearch(field, value, 'either')
      }
    ];

    ContextMenu.open(e, menuItems, 'eventsQueryMenu');
    e.stopPropagation();
  }
  /**
   * Add tree node to search filter
   * @method
   * @param {string} field - corresponding field of selected node
   * @param {string} value - selected node name
   * @param {string} type - condition of selected node ('must')
   * @returns none
   */
  addSearch = (field, value, type) => {
    const {filterData} = this.state;
    let currentFilterData = filterData;

    if (filterData.length === 0) {
      currentFilterData.push({});
    }

    if (field) {
      value = field + ': ' + value;
    }

    _.forEach(filterData, (val, i) => {
      if (filterData[filterData.length - 1].query) {
        currentFilterData.push({
          condition: type,
          query: value
        });
        return false;
      }

      if (!currentFilterData[i].query) {
        currentFilterData[i].condition = type;
        currentFilterData[i].query = value;
        return false;
      }
    })

    this.setState({
      showFilter: true,
      filterData: currentFilterData
    });
  }
  /**
   * Handle value change for the checkbox in the table dialog
   * @method
   * @param {string} field - field of selected checkbox
   * @param {boolean} data - checked/uncheck status
   * @returns none
   */
  setFieldsChange = (field, data) => {
    let tempAccount = {...this.state.account};

    if (_.includes(tempAccount.fields, field)) {
      if (!data) {
        const index = tempAccount.fields.indexOf(field);
        tempAccount.fields.splice(index, 1);
      }
    } else {
      if (data) {
        tempAccount.fields.push(field);
      }
    }

    this.setCustomFields(tempAccount.fields);
  }
  /**
   * Set and save events table fields of the account
   * @method
   * @param {array} fields - fields list to be set
   * @returns none
   */
  setCustomFields = (fields) => {
    const {baseUrl} = this.props;
    const {activeTab, account} = this.state;
    let tempAccount = {...account};
    let fieldString = '';
    let url = '';
    let module = '';
    tempAccount.fields = fields;

    _.forEach(fields, value => {
      fieldString += '&amp;field=' + value;
    })

    if (activeTab === 'connections') {
      module = 'FLOW_SESSION';
    } else {
      module = 'FLOW_' + activeTab.toUpperCase();
    }
    url = `${baseUrl}/api/account/flow/fields?module=${module}&amp;accountId=${account.id}${fieldString}`;

    ah.one({
      url,
      type: 'POST'
    })
    .then(data => {
      if (data.status === 'success') {
        this.setState({
          account: tempAccount
        });
      }
      return null;
    })
  }
  /**
   * Set the table raw index and netflow data
   * @method
   * @param {string | object} data - button action type ('previous' or 'next'), or data object
   * @returns object of index and data
   */
  handleDialogNavigation = (data) => {
    const {activeTab, subSectionsData, currentTableIndex} = this.state;
    let tableRowIndex = '';
    let allValue = {};

    if (data === 'next' || data === 'previous') { //For click on navigation button
      tableRowIndex = currentTableIndex;

      if (data === 'next') {
        tableRowIndex++;
      } else if (data === 'previous') {
        tableRowIndex--;
      }
      allValue = subSectionsData.mainData[activeTab][tableRowIndex];
    } else { //For click on table raw
      tableRowIndex = _.findIndex(subSectionsData.mainData[activeTab], {'id': data.id});
      allValue = data;
    }

    return {
      tableRowIndex,
      allValue
    };
  }
  /**
   * Set the data to be displayed in table dialog
   * @method
   * @param {object} allValue - data of selected table raw
   * @returns none
   */
  showTableData = (allValue) => {
    const {account} = this.state;
    const newData = this.handleDialogNavigation(allValue);
    const currentTableIndex = newData.tableRowIndex;
    let filteredAllValue = {};
    allValue = newData.allValue;

    _.forEach(allValue, (value, key) => {
      if (typeof value === 'object') {
        if (key === 'dns') {
          if (value['opcode-term']) {
            filteredAllValue['dns.opcode-term'] = helper.arrayDataJoin(value['opcode-term'], '', ', ');
          }
          if (value['status-term']) {
            filteredAllValue['dns.status-term'] = helper.arrayDataJoin(value['status-term'], '', ', ');
          }
        }
        if (key === 'tcpflags') {
          filteredAllValue['tcpflags.fin'] = value.fin;
          filteredAllValue['tcpflags.rst'] = value.rst;
        }
      } else {
        filteredAllValue[key] = value;
      }
    })

    const hiddenFields = ['id', '_tableMenu_', 'root_id', 'sessionId', 'projectName', 'timestamp', 'dns', 'tcpflags', 'alert', 'http', 'tag'];
    let dataList = _.omit(filteredAllValue, hiddenFields);
    let dataToShow = {};
    let dataToHide = {};
    let sortedDataList = [];

    _.forEach(account.fields, val => {
      dataToShow[val] = dataList[val];
    })

    dataToShow = _.pick(dataList, account.fields);
    dataToHide = _.omit(dataList, account.fields);
    _.assign(dataToShow, dataToHide);

    _.forEach(dataToShow, (val, key) => {
      let tempObj = {};
      tempObj[key] = val;
      sortedDataList.push(tempObj);
    })

    this.setState({
      sortedDataList,
      modalOpen: true,
      currentTableIndex,
      currentTableID: allValue.id
    });
  }
  /**
   * Handle table field sort action
   * @method
   * @param {object} listObj - sort data
   * @returns none
   */
  onSortEnd = (listObj) => {
    this.setState({
      sortedDataList: arrayMove(this.state.sortedDataList, listObj.oldIndex, listObj.newIndex)
    });
  }
  /**
   * Display table data content
   * @method
   * @param none
   * @returns HTML DOM
   */
  displayTableData = () => {
    const {activeTab, sortedDataList, currentTableIndex, currentLength} = this.state;

    return (
      &lt;div className='parent-content'>
        &lt;SortableList
          activeTab={activeTab}
          items={sortedDataList}
          onSortEnd={this.onSortEnd}
          setFieldsChange={this.setFieldsChange}
          checkDisplayFields={this.checkDisplayFields}
          showQueryOptions={this.showQueryOptions}
          useDragHandle={true}
          lockToContainerEdges={true} />

        {currentLength > 1 &amp;&amp;
          &lt;div className='pagination'>
            &lt;div className='buttons'>
              &lt;button onClick={this.showTableData.bind(this, 'previous')} disabled={currentTableIndex === 0}>{t('txt-previous')}&lt;/button>
              &lt;button onClick={this.showTableData.bind(this, 'next')} disabled={currentTableIndex + 1 == currentLength}>{t('txt-next')}&lt;/button>
            &lt;/div>
            &lt;span className='count'>{currentTableIndex + 1} / {currentLength}&lt;/span>
          &lt;/div>
        }
      &lt;/div>
    )
  }
  /**
   * Close dialog and reset data
   * @method
   * @param none
   * @returns none
   */
  closeDialog = () => {
    this.setState({
      modalOpen: false,
      openQueryOpen: false,
      saveQueryOpen: false,
      taggingOpen: false,
      pcapOpen: false
    }, () => {
      this.clearTagData();
      this.clearPcapData();
      this.clearQueryData();
    });
  }
  /**
   * Reset table based on user's interaction with table dialog or memo tag
   * @method
   * @param {string} options - option for 'setFields'
   * @returns none
   */
  resetDataTable = (options) => {
    const {activeTab, subSectionsData} = this.state;
    let tempSubSectionsData = {...subSectionsData};
    tempSubSectionsData.mainData[activeTab] = [];
    tempSubSectionsData.fieldsData[activeTab] = {};
    tempSubSectionsData.totalCount[activeTab] = 0;

    this.setState({
      subSectionsData: tempSubSectionsData
    }, () => {
      const {account, sortedDataList} = this.state;
      let sortedCheckedList = [];

      _.forEach(sortedDataList, val => {
        const item = _.keys(val).toString();

        if (_.includes(account.fields, item)) {
          sortedCheckedList.push(item);
        }
      });

      if (options === 'setFields') {
        this.setCustomFields(sortedCheckedList);
      }
      this.closeDialog();
      this.clearData();
    });
  }
  /**
   * Display table data content in modal dialog
   * @method
   * @param none
   * @returns none
   */
  tableDialog = () => {
    const {activeTab} = this.state;
    const actions = {
      cancel: {text: t('txt-cancel'), className: 'standard', handler: this.closeDialog},
      confirm: {text: t('txt-confirm'), handler: this.resetDataTable.bind(this, 'setFields')}
    };
    const titleText = ALL_TAB_DATA[activeTab] + ' ' + t('txt-table');

    return (
      &lt;ModalDialog
        id='flowModalDialog'
        className='modal-dialog'
        title={titleText}
        draggable={true}
        global={true}
        actions={actions}
        closeAction='cancel'>
        {this.displayTableData()}
      &lt;/ModalDialog>
    )
  }
  /**
   * Display Json data content
   * @method
   * @param none
   * @returns HTML DOM
   */
  displayJsonData = (allValue) => {
    const {currentTableIndex, currentLength} = this.state;
    const hiddenFields = ['id', '_tableMenu_'];
    allValue = _.omit(allValue, hiddenFields);

    return (
      &lt;div className='json-reports'>
        &lt;ul className='json-data'>
          &lt;li>&lt;JSONTree data={allValue} theme={helper.getJsonViewTheme()} />&lt;/li>
        &lt;/ul>

        {currentLength > 1 &amp;&amp;
          &lt;div className='pagination json'>
            &lt;div className='buttons'>
              &lt;button onClick={this.viewJsonData.bind(this, 'previous')} disabled={currentTableIndex === 0}>{t('txt-previous')}&lt;/button>
              &lt;button onClick={this.viewJsonData.bind(this, 'next')} disabled={currentTableIndex + 1 == currentLength}>{t('txt-next')}&lt;/button>
            &lt;/div>
            &lt;span className='count'>{currentTableIndex + 1} / {currentLength}&lt;/span>
          &lt;/div>
        }
      &lt;/div>
    )
  }
  /**
   * Open Json data modal dialog
   * @method
   * @param {object} allValue - data of selected table raw
   * @returns none
   */
  viewJsonData = (allValue) => {
    const {activeTab} = this.state;
    const newData = this.handleDialogNavigation(allValue);
    const currentTableIndex = newData.tableRowIndex;
    const title = ALL_TAB_DATA[activeTab] + ' JSON';
    allValue = newData.allValue;

    this.setState({
      currentTableIndex,
      currentTableID: allValue.id
    }, () => {
      PopupDialog.alert({
        title,
        id: 'viewJsonDialog',
        confirmText: t('txt-close'),
        display: this.displayJsonData(allValue),
        act: (confirmed, data) => {
        }
      });
    });
  }
  /**
   * Set PCAP hex value
   * @method
   * @param {string} hex - original string value
   * @param {number} index - active index of the Alert PCAP array
   * @returns none
   */
  setPCAPhex = (hex, index) => {
    let tempPcapData = {...this.state.pcapData};

    if (hex) {
      tempPcapData.hex = hex.replace(/\s/g, '');
    } else {
      return false;
    }
    tempPcapData.activeIndex = index;

    this.setState({
      pcapData: tempPcapData
    });
  }
  /**
   * Set PCAP page
   * @method
   * @param {string} currentPage - current page of the PCAP info
   * @returns none
   */
  setPCAPpage = (currentPage) => {
    let tempPcapData = {...this.state.pcapData};
    tempPcapData.page = currentPage;
    tempAlertPCAP.activeIndex = null;
    tempPcapData.hex = '';
    tempPcapData.filterEmpty = false;

    this.setState({
      pcapData: tempPcapData
    }, () => {
      this.getPCAPcontent();
    });
  }
  /**
   * Toggle (check/uncheck) to show/hide the PCAP data
   * @method
   * @param none
   * @returns none
   */
  toggleFilterEmpty = () => {
    const {pcapData} = this.state;
    let tempPcapData = {...pcapData};
    tempPcapData.activeIndex = null;
    tempPcapData.hex = '';
    tempPcapData.filterEmpty = !tempPcapData.filterEmpty;

    if (tempPcapData.filterEmpty) {
      let connectionsPCAPdata = [];

      _.forEach(pcapData.data, val => {
        if (val.hex) {
          connectionsPCAPdata.push(val);
        }
      })
      tempPcapData.data = connectionsPCAPdata;
    } else {
      tempPcapData.data = _.cloneDeep(pcapData.origData);
    }

    this.setState({
      pcapData: tempPcapData
    });
  }
  /**
   * Display individual PCAP data
   * @method
   * @param {object} val - PCAP data
   * @param {number} i - index
   * @returns HTML DOM
   */
  showPCAPcontent = (val, i) => {
    return &lt;li key={i} className={cx({'active': val.hex})} onClick={this.setPCAPhex.bind(this, val.hex, i)}>{val.protocol}&lt;i className={cx('fg', {'fg-arrow-left': this.state.pcapData.activeIndex === i})}>&lt;/i>&lt;/li>  
  }
  /**
   * Display PCAP content
   * @method
   * @param none
   * @returns HTML DOM
   */
  displayPCAPcontent = () => {
    const {pcapData} = this.state;
    const hex = pcapData.hex;
    let str = '';

    if (hex) {
      for (let i = 0; i &lt; hex.length; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
    }

    return (
      &lt;div className='pcap-content'>
        {pcapData.data.length > 0 &amp;&amp;
          &lt;div className='c-flex aic filter-empty'>
            &lt;label htmlFor='filterEmpty'>{t('alert.txt-filterEmpty')}&lt;/label>
            &lt;Checkbox
              id='filterEmpty'
              onChange={this.toggleFilterEmpty}
              checked={pcapData.filterEmpty} />
          &lt;/div>
        }
        &lt;div className='pcap'>
          &lt;div className='list'>
            &lt;ul>
              {pcapData.data &amp;&amp; pcapData.data.length > 0 &amp;&amp;
                pcapData.data.map(this.showPCAPcontent)
              }
            &lt;/ul>
          &lt;/div>
          &lt;div className='data'>
            {str &amp;&amp;
              &lt;Textarea value={str} readOnly={true} />
            }
          &lt;/div>
        &lt;/div>
        {pcapData.totalCount > pcapData.pageSize &amp;&amp;
          &lt;footer>
            &lt;PageNav
              pages={Math.ceil(pcapData.totalCount / pcapData.pageSize)}
              current={pcapData.page}
              onChange={this.setPCAPpage} />
          &lt;/footer>
        }
      &lt;/div>
    )
  }
  /**
   * Display PCAP content in modal dialog
   * @method
   * @param none
   * @returns ModalDialog component
   */
  pcapDialog = () => {
    const titleText = t('events.connections.txt-viewPCAP');
    const actions = {
      cancel: {text: t('txt-cancel'), className: 'standard', handler: this.closeDialog},
      confirm: {text: t('txt-close'), handler: this.closeDialog}
    };

    return (
      &lt;ModalDialog
        id='pcapModalDialog'
        className='modal-dialog'
        title={titleText}
        draggable={true}
        global={true}
        actions={actions}
        closeAction='cancel'>
        {this.displayPCAPcontent()}
      &lt;/ModalDialog>
    )
  }
  /**
   * Get and set PCAP data
   * @method
   * @param {object} allValue - data of selected table raw
   * @returns none
   */
  getPCAPcontent = (allValue) => {
    const {baseUrl} = this.props;
    const {pcapData} = this.state;
    const projectID = allValue ? allValue.projectName : pcapData.projectID;
    const sessionID = allValue ? allValue.id : pcapData.sessionID;
    const url = `${baseUrl}/api/network/session/pcapContent?projectId=${projectID}&amp;sessionId=${sessionID}&amp;page=${pcapData.page}&amp;pageSize=${pcapData.pageSize}`;

    this.ah.one({
      url,
      type: 'GET'
    })
    .then(data => {
      if (data &amp;&amp; !_.isEmpty(data.rows)) {
        let tempPcapData = {...pcapData};
        tempPcapData.projectID = projectID;
        tempPcapData.sessionID = sessionID;
        tempPcapData.origData = data.rows;
        tempPcapData.data = data.rows;
        tempPcapData.totalCount = data.counts;
        tempPcapData.activeIndex = null;
        tempPcapData.hex = '';

        this.setState({
          pcapData: tempPcapData,
          pcapOpen: true
        });
      } else {
        helper.showPopupMsg('', t('txt-pcapNotAvailable'), err.message);
      }
      return null;
    })
    .catch(err => {
      helper.showPopupMsg('', t('txt-error'), err.message);
    })
  }
  /**
   * Display delete tag content
   * @method
   * @param {string} id - ID of selected table raw data
   * @returns HTML DOM
   */
  getDeleteTagContent = (id) => {
    if (id) {
      let tempTagData = {...this.state.tagData};
      tempTagData.id = id;

      this.setState({
        tagData: tempTagData
      });
    }

    return (
      &lt;div className='content delete'>
        &lt;span>{t('txt-delete-msg')}?&lt;/span>
      &lt;/div>
    )
  }
  /**
   * Open delete tag modal dialog
   * @method
   * @param {string} id - ID of selected table raw data
   * @returns none
   */
  deleteTagging = (id) => {
    PopupDialog.prompt({
      title: t('events.connections.txt-deleteTag'),
      id: 'modalWindowSmall',
      confirmText: t('txt-delete'),
      cancelText: t('txt-cancel'),
      display: this.getDeleteTagContent(id),
      act: (confirmed) => {
        if (confirmed) {
          this.deleteTag();
        }
      }
    });
  }
  /**
   * Handle delete tag confirm
   * @method
   * @param none
   * @returns none
   */
  deleteTag = () => {
    const {baseUrl} = this.props;
    const {tagData} = this.state;
    const url = `${baseUrl}/api/account/flow/session?id=${tagData.id}`;

    this.ah.one({
      url,
      type: 'DELETE'
    })
    .then(data => {
      if (data) {
        this.clearTagData();
        this.resetDataTable();
      } else {
        helper.showPopupMsg('', t('txt-error'), err.message);
      }
      return null;
    });
  }
  /**
   * Handle add tag table menu
   * @method
   * @param {object} allValue - data of selected table raw
   * @returns none
   */
  addTagging = (allValue) => {
    let titleText = t('events.connections.txt-addTag');
    let tempTagData = {...this.state.tagData};

    if (allValue.tag) {
      titleText = t('events.connections.txt-editTag');
      tempTagData.id = allValue.tag.id;
      tempTagData.color = allValue.tag.color;
      tempTagData.memo = allValue.tag.memo;
    } else {
      tempTagData.projectID = allValue.projectName;
      tempTagData.sessionID = allValue.id;
    }

    tempTagData.modalTitle = titleText;

    this.setState({
      tagData: tempTagData,
      taggingOpen: true
    });
  }
  /**
   * Handle value change for the add tagging form
   * @method
   * @param {object | string} val - input value
   * @returns none
   */
  handleDataChange = (val) => {
    let tempTagData = {...this.state.tagData};

    if (val.hex) {
      tempTagData.color = val.hex.toUpperCase();
    } else if (val) {
      tempTagData.memo = val;
    }

    this.setState({
      tagData: tempTagData
    });
  }
  /**
   * Display add tagging content
   * @method
   * @param none
   * @returns HTML DOM
   */
  displayAddTagging = () => {
    const {tagData} = this.state;
    const colorList = ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB'];

    return (
      &lt;div>
        &lt;label htmlFor='tagMemo'>{t('txt-memo')} ({t('txt-memoMaxLength')})&lt;/label>
        &lt;Textarea
          id='tagMemo'
          className='add'
          rows={4}
          maxLength={250}
          value={tagData.memo}
          onChange={this.handleDataChange} />
        &lt;div className='group'>
          &lt;label>{t('txt-color')}&lt;/label>
          &lt;GithubPicker
            width='213px'
            colors={colorList}
            triangle='hide'
            onChangeComplete={this.handleDataChange} />
        &lt;/div>
        &lt;div className='group'>
          &lt;label>{t('txt-selected')}&lt;/label>
          &lt;div className='color-box' className={'color-box ' + helper.showColor(tagData.color)}>&lt;/div>
        &lt;/div>
      &lt;/div>
    )
  }
  /**
   * Display add tagging content in modal dialog
   * @method
   * @param none
   * @returns ModalDialog component
   */
  taggingDialog = () => {
    const {tagData} = this.state;
    const titleText = tagData.modalTitle;
    const actions = {
      cancel: {text: t('txt-cancel'), className: 'standard', handler: this.closeDialog},
      confirm: {text: t('txt-confirm'), handler: this.handleAddTagging}
    };

    return (
      &lt;ModalDialog
        id='tagModalDialog'
        className='modal-dialog'
        title={titleText}
        draggable={true}
        global={true}
        actions={actions}
        closeAction='cancel'>
        {this.displayAddTagging()}
      &lt;/ModalDialog>
    )
  }
  /**
   * Handle add tagging confirm
   * @method
   * @param none
   * @returns none
   */
  handleAddTagging = () => {
    const {baseUrl} = this.props;
    const {account, tagData} = this.state;
    const url = `${baseUrl}/api/account/flow/session`;
    let data = {};
    let requestType = 'POST';

    if (tagData.color.indexOf('#') &lt; 0) {
      tagData.color = '#' + tagData.color;
    }

    if (tagData.id) {
      data = {
        id: tagData.id,
        color: tagData.color,
        memo: tagData.memo
      };
      requestType = 'PATCH';
    } else {
      data = {
        accountId: account.id,
        projectId: tagData.projectID,
        sessionId: tagData.sessionID,
        color: tagData.color,
        memo: tagData.memo
      };
    }

    helper.getAjaxData(requestType, url, data)
    .then(data => {
      if (data) {
        this.clearTagData();
        this.resetDataTable();
      } else {
        helper.showPopupMsg('', t('txt-error'), err.message);
      }
      return null;
    });
  }
  /**
   * Handle open image modal dialog in File events
   * @method
   * @param {string} value - image file data
   * @param {object} e - mouseClick events
   * @returns none
   */
  openImageModal = (value) => (e) => {
    PopupDialog.alert({
      id: 'fileModal',
      confirmText: t('txt-close'),
      display: &lt;img src={value} />
    });
  }
  /**
   * Handle open HTML modal dialog
   * @method
   * @param {string} value - HTML path
   * @returns none
   */
  openHTMLModal = (value) => {
    const {baseUrl} = this.props;
    const url = `${baseUrl}/api/network/html/reLinkFile?path=${value}`;

    ah.one({
      url,
      type: 'GET'
    })
    .then(data => {
      PopupDialog.alert({
        id: 'fileModal',
        confirmText: t('txt-close'),
        display: &lt;div dangerouslySetInnerHTML={{__html: data}} />
      });
      return null;
    })
    .catch(err => {
      helper.showPopupMsg('', t('txt-error'), err.message);
    })
  }
  /**
   * Set new datetime
   * @method
   * @param {object} datetime - new datetime object
   * @param {string} refresh - option for 'refresh'
   * @returns none
   */
  handleDateChange = (datetime, refresh) => {
    this.setState({
      datetime
    }, () => {
      if (refresh === 'refresh') {
        this.loadAllFields();
      }
    });
  }
  /**
   * Handle chart type change for Connections events
   * @method
   * @param {string} connectionsChartType - chart type ('connections', 'packets' or 'databytes')
   * @returns none
   */
  handleChartChange = (connectionsChartType) => {
    this.setState({
      connectionsChartType,
      tableMouseOver: false
    });
  }
  /**
   * Handle chart interval change for Connections events
   * @method
   * @param {string} connectionsChartType - chart type ('1m', '15m', '30m' or '60m')
   * @returns none
   */
  handleIntervalChange = (connectionsInterval) => {
    this.setState({
      connectionsInterval,
      tableMouseOver: false
    }, () => {
      this.loadConnections();
    });
  }
  /**
   * Handle show image only checkbox for File events
   * @method
   * @param {boolean} showImgCheckbox - checkbox status (true/false)
   * @returns none
   */
  handleShowImgCheckbox = (showImgCheckbox) => {
    this.setState({
      showImgCheckbox
    }, () => {
      this.loadSubSections(this.state.showImgCheckbox ? 'images' : '');
    });
  }
  /**
   * Handle display change radio for File events
   * @method
   * @param {boolean} displayType - display type ('list' or 'grid')
   * @returns none
   */
  handleDisplayChange = (displayType) => {
    this.setState({
      displayType
    }, () => {
      this.loadSubSections(this.state.showImgCheckbox ? 'images' : '');
    });
  }
  /**
   * Check for File type and grid view
   * @method
   * @param none
   * @returns true/false boolean
   */
  fileImageGrid = () => {
    return (this.state.activeTab === 'file' &amp;&amp; this.state.displayType === 'grid') ? true : false;
  }
  /**
   * Get default page size based on events type
   * @method
   * @param none
   * @returns true/false boolean
   */
  getPageSize = () => {
    const {pageSize, pageSizeGrid} = this.state;

    if (this.fileImageGrid()) {
      return pageSizeGrid;
    } else {
      return pageSize;
    }
  }
  /**
   * Handle content tab change
   * @method
   * @param {string} newTab - content type ('table', 'linkAnalysis' or 'worldMap')
   * @returns none
   */
  handleSubTabChange = (newTab) => {
    const {activeTab} = this.state;

    if (newTab === 'worldMap') {
      this.loadWorldMap();

      this.setState({
        currentPage: 1,
        pageSizeMap: 500,
        tableMouseOver: false
      });
    } else {
      if (newTab === 'table') {
        this.setState({
          currentPage: 1,
          pageSize: 20
        }, () => {
          if (activeTab === 'connections') {
            this.loadConnections();
          } else {
            this.loadSubSections();
          }
        });
      } else if (newTab === 'linkAnalysis') {
        this.setState({
          currentPage: 1,
          pageSizeMap: 500
        }, () => {
          this.resetLinkAnalysis();
        });
      }

      this.setState({
        activeSubTab: newTab,
        tableMouseOver: false
      });
    }
  }
  /**
   * Display table data content for events type
   * @method
   * @param none
   * @returns events component
   */
  renderTabContent = () => {
    const {baseUrl, contextRoot, language, searchFields} = this.props;
    const {activeTab, tableMouseOver} = this.state;
    const mainContentData = {
      allTabData: ALL_TAB_DATA,
      searchFields,
      activeTab,
      tableMouseOver,
      tableUniqueID: 'id',
      subTabMenu: this.state.subTabMenu,
      activeSubTab: this.state.activeSubTab,
      handleSubTabChange: this.handleSubTabChange,
      currentTableID: this.state.currentTableID,
      queryData: this.state.queryData,
      eventsCount: this.state.eventsCount,
      filterData: this.state.filterData,
      account: this.state.account,
      showFilter: this.state.showFilter,
      showChart: this.state.showChart,
      toggleFilter: this.toggleFilter,
      toggleChart: this.toggleChart,
      openQuery: this.openQuery,
      setFilterData: this.setFilterData,
      handleResetBtn: this.handleResetBtn,
      handleSearchSubmit: this.handleSearchSubmit,
      handleTabChange: this.handleTabChange,
      treeTitle: t('events.connections.txt-top10text'),
      treeShowDropDown: true,
      treeData: this.state.treeData,
      treeSelect: this.selectTree,
      showTreeFilterBtn: this.showTreeFilterBtn,
      showImageValue: this.state.showImgCheckbox,
      handleShowImgCheckbox: this.handleShowImgCheckbox,
      displayImgType: this.state.displayType,
      handleDisplayChange: this.handleDisplayChange,
      openImageModal: this.openImageModal,
      dataTableData: this.state.subSectionsData.mainData[activeTab],
      dataTableFields: this.state.subSectionsData.fieldsData[activeTab],
      LAdata: this.state.subSectionsData.laData[activeTab],
      mapData: this.state.subSectionsData.mapData[activeTab],
      LAconfig: this.state.LAconfig,
      mainEventsData: this.state.mainEventsData,
      geoJson: this.state.geoJson,
      dataTableSort: this.state.sort,
      handleTableSort: this.handleTableSort,
      handleRowMouseOver: this.handleRowMouseOver,
      handleRowMouseOut: this.handleRowMouseOut,
      paginationTotalCount: this.state.subSectionsData.totalCount[activeTab],
      paginationPageSize: this.getPageSize(),
      paginationAlertPageSize: this.state.pageSizeMap,
      paginationCurrentPage: this.state.currentPage,
      paginationPageChange: this.handlePaginationChange,
      paginationDropDownChange: this.handlePageDropdown,
      paginationAlertPageChange: this.handleLargePageChange,
      paginationAlertDropDownChange: this.handleLargePageDropdown
    };

    if (activeTab === 'connections') {
      return (
        &lt;Connections
          contextRoot={contextRoot}
          baseUrl={baseUrl}
          mainContentData={mainContentData}
          tabChartData={{
            sessionHistogram: this.state.sessionHistogram,
            packageHistogram: this.state.packageHistogram,
            byteHistogram: this.state.byteHistogram,
            chartTypeChange: this.handleChartChange,
            chartTypeValue: this.state.connectionsChartType,
            chartIntervalChange: this.handleIntervalChange,
            chartIntervalValue: this.state.connectionsInterval
          }}
          tableMouseOver={tableMouseOver} />
      )
    } else if (activeTab === 'dns') {
      return (
        &lt;Dns
          mainContentData={mainContentData} />
      )
    } else if (activeTab === 'http') {
      return (
        &lt;Http
          mainContentData={mainContentData} />
      )
    } else if (activeTab === 'html') {
      return (
        &lt;Html
          mainContentData={mainContentData} />
      )
    } else if (activeTab === 'email') {
      return (
        &lt;Email
          mainContentData={mainContentData} />
      )
    } else if (activeTab === 'file') {
      return (
        &lt;File
          mainContentData={mainContentData} />
      )
    } else if (activeTab === 'cert') {
      return (
        &lt;Certification
          mainContentData={mainContentData} />
      )
    } else if (activeTab === 'ftp') {
      return (
        &lt;Ftp
          mainContentData={mainContentData} />
      )
    }
  }
  /**
   * Handle CSV download
   * @method
   * @param none
   * @returns none
   */
  getCSVfile = () => {
    const {baseUrl, contextRoot} = this.props;
    const {projectID, activeTab, account} = this.state;
    const projectIDstring = this.getProjectURL(projectID);
    const type = activeTab === 'connections' ? 'session' : activeTab;
    const url = `${baseUrl}${contextRoot}/api/network/${type}/_export?${projectIDstring}`;
    let tempColumns = [];

    _.forEach(account.fields, val => {
      if (val !== 'alertRule' &amp;&amp; val != '_tableMenu_') {
        tempColumns.push({
          [val]: f(`${activeTab}Fields.${val}`)
        });
      }
    })

    const dataOptions = {
      ...this.toQueryLanguage(),
      columns: tempColumns
    };

    downloadWithForm(url, {payload: JSON.stringify(dataOptions)});
  }
  /**
   * Toggle filter content on/off
   * @method
   * @param none
   * @returns none
   */
  toggleFilter = () => {
    this.setState({
      showFilter: !this.state.showFilter
    });
  }
  /**
   * Toggle query menu on/off
   * @method
   * @param {string} type - type of query menu ('open' or 'save')
   * @returns none
   */
  openQuery = (type) => {
    if (type === 'open') {
      this.setState({
        openQueryOpen: true
      });
    } else if (type === 'save') {
      this.setState({
        saveQueryOpen: true
      });
    }
  }
  /**
   * Set filter data
   * @method
   * @param {array} filterData - filter data to be set
   * @returns none
   */
  setFilterData = (filterData) => {
    this.setState({
      filterData
    });
  }
  /**
   * Set query data
   * @method
   * @param {object} queryData - query data to be set
   * @returns none
   */
  setQueryData = (queryData) => {
    this.setState({
      queryData
    });
  }
  /**
   * Display query menu modal dialog
   * @method
   * @param {string} type - query type ('open' or 'save')
   * @returns QueryOpenSave component
   */
  queryDialog = (type) => {
    const {baseUrl, contextRoot} = this.props;
    const {activeTab, account, filterData, queryData} = this.state;

    return (
      &lt;QueryOpenSave
        baseUrl={baseUrl}
        contextRoot={contextRoot}
        activeTab={activeTab}
        type={type}
        account={account}
        filterData={filterData}
        queryData={queryData}
        setFilterData={this.setFilterData}
        setQueryData={this.setQueryData}
        setMarkData={this.setMarkData}
        getSavedQuery={this.getSavedQuery}
        closeDialog={this.closeDialog} />
    )
  }
  /**
   * Toggle chart content on/off
   * @method
   * @param none
   * @returns none
   */
  toggleChart = () => {
    this.setState({
      showChart: !this.state.showChart
    });
  }
  /**
   * Set search options data
   * @method
   * @param {string} type - search type to be set ('all' and others)
   * @param {string} value - search value to be set
   * @returns none
   */
  setSearchData = (type, value) => {
    if (type === 'all') {
      this.setState({
        searchInput: value
      });
    } else {
      let tempSearchInput = {...this.state.searchInput};

      if (value) {
        tempSearchInput[type] = value;

        this.setState({
          searchInput: tempSearchInput
        });
      }
    }
  }
  /**
   * Clear memo tag data
   * @method
   * @param none
   * @returns none
   */
  clearTagData = () => {
    const tagData = {
      id: '',
      projectID: '',
      sessionID: '',
      modalTitle: '',
      color: '#FCCB00',
      memo: ''
    };

    this.setState({
      tagData
    });
  }
  /**
   * Clear PCAP data
   * @method
   * @param none
   * @returns none
   */
  clearPcapData = () => {
    const pcapData = {
      projectID: '',
      sessionID: '',
      data: [],
      page: 1,
      pageSize: 10,
      totalCount: 0,
      activeIndex: null,
      hex: ''
    };

    this.setState({
      pcapData
    });
  }
  /**
   * Reset query data
   * @method
   * @param none
   * @returns none
   */
  clearQueryData = () => {
    const {queryData} = this.state;
    let tempQueryData = {...queryData};
    tempQueryData.inputName = '';
    tempQueryData.openFlag = false;

    this.setState({
      queryData: tempQueryData
    });
  }
  /**
   * Reset subSections data
   * @method
   * @param none
   * @returns none
   */
  clearData = () => {
    const subSectionsData = {
      mainData: {
        connections: [],
        dns: [],
        http: [],
        html: [],
        email: [],
        file: [],
        cert: [],
        ftp: []
      },
      fieldsData: {
        connections: {},
        dns: {},
        http: {},
        html: {},
        email: {},
        file: {},
        cert: {},
        ftp: {}
      },
      laData: {
        connections: []
      },
      mapData: {
        connections: []
      },
      tableColumns: {},
      totalCount: {
        connections: 0,
        dns: 0,
        http: 0,
        html: 0,
        email: 0,
        file: 0,
        cert: 0,
        ftp: 0
      }
    };

    this.setState({
      subSectionsData
    }, () => {
      this.loadAllFields();
    });
  }
  render() {
    const {locale, session} = this.props;
    const {
      activeTab,
      datetime,
      subSectionsData,
      searchInput,
      modalOpen,
      openQueryOpen,
      saveQueryOpen,
      taggingOpen,
      filterData,
      pcapOpen,
      showChart,
      showFilter
    } = this.state;
    let sessionRights = {};
    let filterDataCount = 0;

    _.forEach(session.rights, val => {
      sessionRights[val] = true;
    })

    _.forEach(filterData, val => {
      if (val.query) {
        filterDataCount++;
      }
    })

    if (!sessionRights.Module_FlowAnalysis_Manage) {
      return;
    }

    return (
      &lt;div>
        {modalOpen &amp;&amp;
          this.tableDialog()
        }

        {openQueryOpen &amp;&amp;
          this.queryDialog('open')
        }

        {saveQueryOpen &amp;&amp;
          this.queryDialog('save')
        }

        {taggingOpen &amp;&amp;
          this.taggingDialog()
        }

        {pcapOpen &amp;&amp;
          this.pcapDialog()
        }

        &lt;div className='sub-header'>
          {helper.getEventsMenu('netflow', sessionRights)}

          &lt;SearchOptions
            locale={locale}
            position='180px'
            datetime={datetime}
            searchInput={searchInput}
            showFilter={showFilter}
            showInterval={true}
            setSearchData={this.setSearchData}
            handleDateChange={this.handleDateChange}
            handleSearchSubmit={this.handleSearchSubmit} />

          &lt;div className='secondary-btn-group right'>
            &lt;button className={cx({'active': showFilter})} onClick={this.toggleFilter} title={t('events.connections.txt-toggleFilter')}>&lt;i className='fg fg-filter'>&lt;/i>&lt;span>({filterDataCount})&lt;/span>&lt;/button>
            &lt;button className={cx({'active': showChart})} onClick={this.toggleChart} disabled={activeTab !== 'connections'} title={t('events.connections.txt-toggleChart')}>&lt;i className='fg fg-chart-columns'>&lt;/i>&lt;/button>
            &lt;button className='last' onClick={this.getCSVfile} title={t('events.connections.txt-exportCSV')}>&lt;i className='fg fg-data-download'>&lt;/i>&lt;/button>
          &lt;/div>
        &lt;/div>

        {this.renderTabContent()}
      &lt;/div>
    )
  }
}

Netflow.propTypes = {
  baseUrl: PropTypes.string.isRequired,
  contextRoot: PropTypes.string.isRequired,
  language: PropTypes.string.isRequired,
  locale: PropTypes.string.isRequired,
  searchFields: PropTypes.object.isRequired,
  session: PropTypes.object.isRequired
};

const HocNetflowController = withRouter(withLocale(Netflow));
export { Netflow, HocNetflowController };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountEdit.html">AccountEdit</a></li><li><a href="AccountList.html">AccountList</a></li><li><a href="Alert.html">Alert</a></li><li><a href="AlertController.html">AlertController</a></li><li><a href="AlertDetails.html">AlertDetails</a></li><li><a href="AutoSettings.html">AutoSettings</a></li><li><a href="ChartContent.html">ChartContent</a></li><li><a href="Config.html">Config</a></li><li><a href="Connections.html">Connections</a></li><li><a href="DashboardMaps.html">DashboardMaps</a></li><li><a href="DashboardStats.html">DashboardStats</a></li><li><a href="DataChart.html">DataChart</a></li><li><a href="Edge.html">Edge</a></li><li><a href="EditHosts.html">EditHosts</a></li><li><a href="File.html">File</a></li><li><a href="FileUpload.html">FileUpload</a></li><li><a href="FilterContent.html">FilterContent</a></li><li><a href="FilterInput.html">FilterInput</a></li><li><a href="FloorMap.html">FloorMap</a></li><li><a href="Header.html">Header</a></li><li><a href="HMDscanInfo.html">HMDscanInfo</a></li><li><a href="IpRange.html">IpRange</a></li><li><a href="Login.html">Login</a></li><li><a href="Manage.html">Manage</a></li><li><a href="MarkContent.html">MarkContent</a></li><li><a href="MarkInput.html">MarkInput</a></li><li><a href="Netflow.html">Netflow</a></li><li><a href="NetworkInventory.html">NetworkInventory</a></li><li><a href="NetworkMap.html">NetworkMap</a></li><li><a href="NetworkOwner.html">NetworkOwner</a></li><li><a href="Notifications.html">Notifications</a></li><li><a href="Pagination.html">Pagination</a></li><li><a href="PrivateDetails.html">PrivateDetails</a></li><li><a href="PrivilegeAdd.html">PrivilegeAdd</a></li><li><a href="PrivilegeEdit.html">PrivilegeEdit</a></li><li><a href="QueryOpenSave.html">QueryOpenSave</a></li><li><a href="Relationships.html">Relationships</a></li><li><a href="ResetPwd.html">ResetPwd</a></li><li><a href="Roles.html">Roles</a></li><li><a href="SafetyScan.html">SafetyScan</a></li><li><a href="Scanner.html">Scanner</a></li><li><a href="SearchFilter.html">SearchFilter</a></li><li><a href="SearchMark.html">SearchMark</a></li><li><a href="SearchOptions.html">SearchOptions</a></li><li><a href="SortableItem.html">SortableItem</a></li><li><a href="SortableList.html">SortableList</a></li><li><a href="Status.html">Status</a></li><li><a href="Syslog.html">Syslog</a></li><li><a href="SyslogController.html">SyslogController</a></li><li><a href="TableCell.html">TableCell</a></li><li><a href="TableContent.html">TableContent</a></li><li><a href="ThreatIntelligence.html">ThreatIntelligence</a></li><li><a href="Tree.html">Tree</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Nov 21 2019 18:21:44 GMT+0800 (台北標準時間)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
