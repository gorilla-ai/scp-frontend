<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/common/hmd-scan-info.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/common/hmd-scan-info.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from 'react'
import { Link } from 'react-router-dom'
import PropTypes from 'prop-types'
import Moment from 'moment'
import _ from 'lodash'
import cx from 'classnames'

import ButtonGroup from 'react-ui/build/src/components/button-group'
import DataTable from 'react-ui/build/src/components/table'
import ModalDialog from 'react-ui/build/src/components/modal-dialog'

import helper from './helper'
import withLocale from '../../hoc/locale-provider'

import {default as ah, getInstance} from 'react-ui/build/src/utils/ajax-helper'

const NOT_AVAILABLE = 'N/A';
const SAFETY_SCAN_LIST = [
  {
    type: 'yara',
    path: 'ScanResult'
  },
  {
    type: 'yaraScanFile',
    path: 'ScanResult'
  },
  {
    type: 'malware',
    path: 'DetectionResult'
  },
  {
    type: 'gcb',
    path: 'GCBResult'
  },
  {
    type: 'ir',
    path: '_ZipPath'
  }
];
const TRIGGER_NAME = {
  [SAFETY_SCAN_LIST[0].type]: 'compareIOC',
  [SAFETY_SCAN_LIST[1].type]: 'yaraScanFile',
  [SAFETY_SCAN_LIST[2].type]: 'malwareDetection',
  [SAFETY_SCAN_LIST[3].type]: 'gcbDetection'
};

let t = null;
let f = null;

/**
 * HMD Scan Info
 * @class
 * @author Ryan Chen &lt;ryanchen@telmediatech.com>
 * @summary A react component to show the HMD scan information
 */
class HMDscanInfo extends Component {
  constructor(props) {
    super(props);

    this.state = {
      activeTab: 'yara', //yara, yaraScanFile, malware, gcb, ir
      activePath: null,
      activeRuleHeader: false,
      activeRule: [],
      activeDLL: false,
      activeConnections: false,
      malwareFieldsArr: ['_FileInfo._Filepath', '_FileInfo._Filesize', '_FileInfo._HashValues._MD5', '_IsPE', '_IsPEextension', '_IsVerifyTrust'],
      malwareSort: ['asc'],
      gcbFieldsArr: ['_CceId', '_OriginalKey', '_Type', '_CompareResult'],
      gcbSort: 'asc',
    };

    t = chewbaccaI18n.getFixedT(null, 'connections');
    f = chewbaccaI18n.getFixedT(null, 'tableFields');
    this.ah = getInstance('chewbacca');
  }
  componentDidUpdate(prevProps) {
    if (!prevProps || (this.props.currentDeviceData.ip !== prevProps.currentDeviceData.ip)) {
      this.setState({
        activeTab: 'yara'
      });
    }
  }
  /**
   * Sort the Yara and Yara Scan File by matched file availablility
   * @method
   * @param {object} scanResult - scan file for Yara and Yara Scan File
   * @returns sorted and mereged list
   */
  sortedRuleList = (scanResult) => {
    let ruleWithFile = [];
    let ruleWithNoFile = [];
    let mergedRule = [];

    _.forEach(scanResult, val => {
      if (val._MatchedFile) {
        ruleWithFile.push(val);
      } else {
        ruleWithNoFile.push(val);
      }
    })

    mergedRule = _.concat(ruleWithFile, ruleWithNoFile);
    return mergedRule;
  }
  /**
   * Set active tab based on scan type
   * @method
   * @param {string} activeTab - active scan type
   */
  toggleScanType = (activeTab) => {
    this.setState({
      activeTab,
      activePath: null,
      activeRuleHeader: false,
      activeRule: [],
      activeDLL: false,
      activeConnections: false
    });
  }
  /**
   * Compare the task create datetime and task response datetime
   * @method
   * @param {string} type - scan type
   * @returns boolean true/false
   */
  checkTriggerTime = (type) => {
    const {currentDeviceData} = this.props;
    const resultType = type + 'Result';

    if (currentDeviceData[resultType].taskCreateDttm &amp;&amp; currentDeviceData[resultType].taskResponseDttm) {
      const createTime = helper.getFormattedDate(currentDeviceData[resultType].taskCreateDttm, 'local');
      const responseTime = helper.getFormattedDate(currentDeviceData[resultType].taskResponseDttm, 'local');

      return Moment(createTime).isAfter(responseTime);
    }
  }
  /**
   * Toggle scan path/rule on/off and set the rule
   * @method
   * @param {string} type - scan type
   * @param {number} i - index of the rule array
   */
  togglePathRule = (type, i) => {
    const {activePath, activeRule} = this.state;
    const tempActivePath = activePath === i ? null : i;

    if (type === 'path') {
      this.setState({
        activePath: tempActivePath,
        activeRuleHeader: false,
        activeRule: [],
        activeDLL: false,
        activeConnections: false
      });
    } else if (type === 'rule') {
      let tempActiveRule = activeRule;

      if (_.includes(activeRule, i)) {
        tempActiveRule.splice(tempActiveRule.indexOf(i), 1);
      } else {
        tempActiveRule.push(i);
      }

      this.setState({
        activeRule: tempActiveRule
      });
    }
  }
  /**
   * Display rule for yara scan
   * @method
   * @param {array} nameList - scan rule list
   * @param {number} i - index of the rule array
   * @returns HTML DOM
   */
  displayRule = (nameList, val, i) => {
    const {activeRule} = this.state;
    const uniqueKey = val + i;

    return (
      &lt;div className='rule-content' key={uniqueKey}>
        &lt;div className='header' onClick={this.togglePathRule.bind(this, 'rule', i)}>
          &lt;i className={cx('fg fg-play', {'rotate': _.includes(activeRule, i)})}>&lt;/i>
          &lt;span>{nameList[i]}&lt;/span>
        &lt;/div>
        {val &amp;&amp;
          &lt;code className={cx({'hide': !_.includes(activeRule, i)})}>{val}&lt;/code>
        }
        {!val &amp;&amp;
          &lt;span>{NOT_AVAILABLE}&lt;/span>
        }
      &lt;/div>
    )
  }
  /**
   * Display individual file
   * @method
   * @param {string} val - scan file data
   * @param {number} i - index of the file array
   * @returns HTML DOM
   */
  displayIndividualFile = (val, i) => {
    const uniqueKey = val + i;

    return (
      &lt;div key={uniqueKey}>{val}&lt;/div>
    )
  }
  /**
   * Display file path
   * @method
   * @param {object} val - scan file data
   * @returns HTML DOM
   */
  displayFilePath = (val) => {
    const {activeDLL} = this.state;
    let filePathList = [];
    let displayInfo = '';

    _.forEach(val._ProcessInfo._ModulesInfo, val2 => {
      if (val2._FileInfo &amp;&amp; val2._FileInfo._Filepath) {
        filePathList.push(val2._FileInfo._Filepath);
      }
    })

    if (filePathList.length > 0) {
      displayInfo = filePathList.map(this.displayIndividualFile);
    } else {
      displayInfo = NOT_AVAILABLE;
    }

    return (
      &lt;div className={cx('sub-content', {'hide': !activeDLL})}>
        {displayInfo}
      &lt;/div>
    )
  }
  /**
   * Display individual connection for Yara Scan
   * @method
   * @param {object} val - connection data
   * @param {number} i - index of the connections array
   * @returns HTML DOM
   */
  displayIndividualConnection = (val, i) => {
    const uniqueKey = val + i;

    return (
      &lt;ul key={uniqueKey}>
        &lt;li>&lt;span>{t('attacksFields.protocolType')}:&lt;/span> {val.protocol || NOT_AVAILABLE}&lt;/li>
        &lt;li>&lt;span>{t('attacksFields.srcIp')}:&lt;/span> {val.srcIp || NOT_AVAILABLE}&lt;/li>
        &lt;li>&lt;span>{t('attacksFields.srcPort')}:&lt;/span> {val.srcPort || NOT_AVAILABLE}&lt;/li>
        &lt;li>&lt;span>{t('attacksFields.destIp')}:&lt;/span> {val.destIP || NOT_AVAILABLE}&lt;/li>
        &lt;li>&lt;span>{t('attacksFields.destPort')}:&lt;/span> {val.destPort || NOT_AVAILABLE}&lt;/li>
      &lt;/ul>
    )
  }
  /**
   * Display connections for Yara Scan
   * @method
   * @param {object} val - connection data
   * @returns HTML DOM
   */
  displayConnections = (val) => {
    const {activeConnections} = this.state;
    let connectionsList = [];
    let displayInfo = '';

    _.forEach(val._ProcessInfo._ConnectionList, val2 => {
      connectionsList.push({
        destIp: val2._DstIP,
        destPort: val2._DstPort,
        protocol: val2._ProtocolType,
        srcIp: val2._SrcIP,
        srcPort: val2._SrcPort
      });
    })

    if (connectionsList.length > 0) {
      displayInfo = connectionsList.map(this.displayIndividualConnection);
    } else {
      displayInfo = NOT_AVAILABLE;
    }

    return (
      &lt;div className={cx('sub-content flex', {'hide': !activeConnections})}>
        {displayInfo}
      &lt;/div>
    )
  }
  /**
   * Toggle scan rule item on/off
   * @method
   * @param {string} type - item type ('rule', 'dll' or 'connections')
   */
  toggleInfoHeader = (type) => {
    if (type === 'rule') {
      this.setState({
        activeRuleHeader: !this.state.activeRuleHeader
      });
    } else if (type === 'dll') {
      this.setState({
        activeDLL: !this.state.activeDLL
      });
    } else if (type === 'connections') {
      this.setState({
        activeConnections: !this.state.activeConnections
      });
    }
  }
  /**
   * Display Yara Scan Process content
   * @method
   * @param {object} val - scan data content
   * @param {number} i - index of the scan process array
   * @returns HTML DOM
   */
  displayScanProcessPath = (val, i) => {
    const {activePath, activeRuleHeader, activeDLL, activeConnections} = this.state;
    const uniqueKey = val._ScanType + i;
    let displayInfo = '';

    if (val._MatchedRuleList &amp;&amp; val._MatchedRuleList.length > 0 &amp;&amp; val._MatchedRuleNameList) {
      displayInfo = val._MatchedRuleList.map(this.displayRule.bind(this, val._MatchedRuleNameList));
    } else {
      displayInfo = NOT_AVAILABLE;
    }

    if (val._MatchedFile || val._MatchedPid) {
      return (
        &lt;div className='group' key={uniqueKey}>
          &lt;div className='path' onClick={this.togglePathRule.bind(this, 'path', i)}>
            &lt;i className={cx('fg fg-arrow-bottom', {'rotate': activePath === i})}>&lt;/i>
            {val._MatchedFile &amp;&amp;
              &lt;span>{t('txt-path')}: {val._MatchedFile}&lt;/span>
            }
            {val._MatchedFile &amp;&amp; val._MatchedPid &amp;&amp;
              &lt;span>, &lt;/span>
            }
            {val._MatchedPid &amp;&amp;
              &lt;span>PID: {val._MatchedPid}&lt;/span>
            }
          &lt;/div>
          &lt;div className={cx('rule', {'hide': activePath !== i})}>
            &lt;div className='rule-content'>
              &lt;div className='header' onClick={this.toggleInfoHeader.bind(this, 'rule')}>
                &lt;i className={cx('fg fg-play', {'rotate': activeRuleHeader})}>&lt;/i>
                &lt;span>{t('txt-rule')}&lt;/span>
              &lt;/div>
              &lt;div className={cx('sub-content', {'hide': !activeRuleHeader})}>
                {displayInfo}
              &lt;/div>
            &lt;/div>

            &lt;div className='rule-content'>
              &lt;div className='header' onClick={this.toggleInfoHeader.bind(this, 'dll')}>
                &lt;i className={cx('fg fg-play', {'rotate': activeDLL})}>&lt;/i>
                &lt;span>DLLs&lt;/span>
              &lt;/div>
              {this.displayFilePath(val)}
            &lt;/div>

            &lt;div className='rule-content'>
              &lt;div className='header' onClick={this.toggleInfoHeader.bind(this, 'connections')}>
                &lt;i className={cx('fg fg-play', {'rotate': activeConnections})}>&lt;/i>
                &lt;span>{t('txt-networkBehavior')}&lt;/span>
              &lt;/div>
              {this.displayConnections(val)}
            &lt;/div>
          &lt;/div>
        &lt;/div>
      )
    }
  }
  /**
   * Display Yara Scan File content
   * @method
   * @param {object} val - scan file content
   * @param {number} i - index of the scan file array
   * @returns HTML DOM
   */
  displayScanFilePath = (val, i) => {
    const {activePath, activeRuleHeader} = this.state;
    const uniqueKey = val._ScanType + i;
    let displayInfo = '';

    if (val._MatchedRuleList &amp;&amp; val._MatchedRuleList.length > 0 &amp;&amp; val._MatchedRuleNameList) {
      displayInfo = val._MatchedRuleList.map(this.displayRule.bind(this, val._MatchedRuleNameList));
    } else {
      displayInfo = NOT_AVAILABLE;
    }

    if (val._MatchedFile || val._MatchedPid) {
      return (
        &lt;div className='group' key={uniqueKey}>
          &lt;div className='path' onClick={this.togglePathRule.bind(this, 'path', i)}>
            &lt;i className={cx('fg fg-arrow-bottom', {'rotate': activePath === i})}>&lt;/i>
            {val._MatchedFile &amp;&amp;
              &lt;span>{t('txt-path')}: {val._MatchedFile}&lt;/span>
            }
            {val._MatchedFile &amp;&amp; val._MatchedPid &amp;&amp;
              &lt;span>, &lt;/span>
            }
            {val._MatchedPid &amp;&amp;
              &lt;span>PID: {val._MatchedPid}&lt;/span>
            }
          &lt;/div>
          &lt;div className={cx('rule', {'hide': activePath !== i})}>
            &lt;div className='rule-content'>
              &lt;div className='header' onClick={this.toggleInfoHeader.bind(this, 'rule')}>
                &lt;i className={cx('fg fg-play', {'rotate': activeRuleHeader})}>&lt;/i>
                &lt;span>{t('txt-rule')}&lt;/span>
              &lt;/div>
              &lt;div className={cx('sub-content', {'hide': !activeRuleHeader})}>
                {displayInfo}
              &lt;/div>
            &lt;/div>
          &lt;/div>
        &lt;/div>
      )
    }
  }
  /**
   * Reset the activeTab and rule data
   * @method
   * @param {string} type - button action type ('previous' or 'next')
   */
  showAlertData = (type) => {
    this.setState({
      activeTab: 'yara',
      activePath: null,
      activeRuleHeader: false,
      activeDLL: false,
      activeConnections: false
    }, () => {
      this.props.showAlertData(type);
    });
  }
  /**
   * Display suspicious file count content
   * @method
   * @param {object} hmdInfo - HMD data
   * @returns HTML DOM
   */
  getSuspiciousFileCount = (hmdInfo) => {
    const {activeTab} = this.state;

    if (hmdInfo[activeTab].count &amp;&amp; hmdInfo[activeTab].count >= 0) {
      return &lt;div className='count'>{t('network-inventory.txt-suspiciousFileCount')}: {hmdInfo[activeTab].count}&lt;/div>
    }
  }
  /**
   * Display pass / total count info
   * @method
   * @param {object} hmdInfo - HMD data
   * @returns HTML DOM
   */
  getPassTotalCount = (hmdInfo) => {
    const {activeTab} = this.state;

    if (hmdInfo[activeTab].filteredResult) {
      let style = '#d10d25'; //Default red color

      if (hmdInfo[activeTab].filteredResult.length === hmdInfo[activeTab].result.length) { //Show green color for all pass
        style = '#22ac38';
      }

      return &lt;span className='pass-total' style={{'color': style}}>{t('network-inventory.txt-passCount')}/{t('network-inventory.txt-totalItem')}: {hmdInfo[activeTab].filteredResult.length}/{hmdInfo[activeTab].result.length}&lt;/span>
    }
  }
  /**
   * Display trigger button for scan type
   * @method
   * @param {object} hmdInfo - HMD data
   * @returns HTML DOM
   */
  getTriggerBtn = (hmdInfo) => {
    const {ipType} = this.props;
    const {activeTab} = this.state;

    if (activeTab === 'ir') {
      return &lt;button className='btn' onClick={this.props.toggleSelectionIR.bind(this, ipType)} disabled={this.checkTriggerTime(activeTab)}>{t('network-inventory.txt-reCompress')}&lt;/button>
    } else if (activeTab === 'gcb') {
      return &lt;button className='btn' onClick={this.props.triggerTask.bind(this, [TRIGGER_NAME[activeTab]], ipType)} disabled={this.checkTriggerTime(activeTab)}>{t('network-inventory.txt-reCheck')}&lt;/button>
    } else {
      return &lt;button className='btn' onClick={this.props.triggerTask.bind(this, [TRIGGER_NAME[activeTab]], ipType)} disabled={this.checkTriggerTime(activeTab)}>{t('network-inventory.txt-reCheck')}&lt;/button>
    }
  }
  /**
   * Display scan content for different scan type
   * @method
   * @param {object} hmdInfo - HMD data
   * @returns HTML DOM
   */
  getScanContent = (hmdInfo) => {
    const {activeTab} = this.state;

    if (activeTab === 'yara' || activeTab === 'yaraScanFile') {
      let scanPath = '';

      if (activeTab === 'yara') {
        scanPath = this.displayScanProcessPath;
      } else if (activeTab === 'yaraScanFile') {
        scanPath = this.displayScanFilePath;
      }

      return (
        &lt;div className='scan-content'>
          &lt;div className='header'>{t('network-inventory.txt-suspiciousFilePath')}&lt;/div>
          {hmdInfo[activeTab].result &amp;&amp; hmdInfo[activeTab].result.length > 0 &amp;&amp;
            &lt;div className='list'>
              {hmdInfo[activeTab].result.map(scanPath)}
            &lt;/div>
          }
          {(!hmdInfo[activeTab].result || hmdInfo[activeTab].result.length === 0) &amp;&amp;
            &lt;div className='empty-msg'>{NOT_AVAILABLE}&lt;/div>
          }
        &lt;/div>
      )
    } else if (activeTab === 'ir') {
      return (
        &lt;div className='scan-content'>
          &lt;div className='header'>{t('network-inventory.txt-irMsg')}:&lt;/div>
          &lt;div className='empty-msg'>{hmdInfo[activeTab].result || NOT_AVAILABLE}&lt;/div>
        &lt;/div>
      )
    }
  }
  /**
   * Get formatted field name
   * @method
   * @param {string} tempData - original field name
   * @returns formatted field name
   */
  getFieldName = (tempData) => {
    if (tempData === '_FileInfo._Filesize') {
      tempData = '_Filesize';
    }
    return 'scan-file' + tempData;
  }
  /**
   * Handle table sort for malware and gcb
   * @method
   */
  handleTableSort = () => {
    const {activeTab, malwareSort, gcbSort} = this.state;

    if (activeTab === 'malware') {
      this.setState({
        malwareSort: malwareSort === 'asc' ? 'desc' : 'asc'
      });
    } else if (activeTab === 'gcb') {
      this.setState({
        gcbSort: gcbSort === 'asc' ? 'desc' : 'asc'
      });
    }
  }
  /**
   * Display table data for malware
   * @method
   * @param {string} activeTab - current active tab
   * @param {object} hmdInfo - HMD data
   * @returns DataTable component
   */
  malwareDataTable = (activeTab, hmdInfo) => {
    return (
      &lt;DataTable
        className='main-table'
        fields={hmdInfo[activeTab].fields}
        data={hmdInfo[activeTab].result}
        onSort={this.handleTableSort} />
    )
  }
  /**
   * Display table data for gcb
   * @method
   * @param {string} activeTab - current active tab
   * @param {object} hmdInfo - HMD data
   * @returns DataTable component
   */
  gcbDataTable = (activeTab, hmdInfo) => {
    return (
      &lt;DataTable
        className='main-table'
        fields={hmdInfo[activeTab].fields}
        data={hmdInfo[activeTab].result}
        onSort={this.handleTableSort} />
    )
  }
  /**
   * Display table content
   * @method
   * @param {object} hmdInfo - HMD data
   * @returns HTML DOM
   */
  getTableContent = (hmdInfo) => {
    const {activeTab, malwareSort, gcbSort} = this.state;

    if (!_.isEmpty(hmdInfo[activeTab].fields) &amp;&amp; hmdInfo[activeTab].result.length > 0) {
      return (
        &lt;div className='table'>
          {activeTab === 'malware' &amp;&amp;
            this.malwareDataTable(activeTab, hmdInfo)
          }
          {activeTab === 'gcb' &amp;&amp;
            this.gcbDataTable(activeTab, hmdInfo)
          }
        &lt;/div>
      )
    }
  }
  render() {
    const {locale, currentDeviceData} = this.props;
    const {activeTab, malwareFieldsArr, gcbFieldsArr, malwareSort, gcbSort} = this.state;

    let hmdInfo = {};
    let buttonGroupList = [];

    _.forEach(SAFETY_SCAN_LIST, val => {
      hmdInfo[val.type] = {}; //Create the hmdInfo object

      buttonGroupList.push({ //Create list for Button group
        value: val.type,
        text: t('network-inventory.scan-list.txt-' + val.type)
      });
    });

    _.forEach(SAFETY_SCAN_LIST, val => { //Construct the HMD info object
      const dataType = val.type + 'Result';
      const currentDataObj = currentDeviceData[dataType];

      if (!_.isEmpty(currentDataObj)) {
        let dataResult = currentDataObj[val.path];

        if (val.path === 'ScanResult') { //For Scan Process and Scan File
          dataResult = this.sortedRuleList(dataResult);
        }

        if (val.type === 'malware') {
          dataResult = _.orderBy(dataResult, ['_IsVerifyTrust'], [malwareSort]);
        }

        if (val.type ===  'gcb') {
          dataResult = _.orderBy(dataResult, ['_CompareResult'], [gcbSort]);
        }

        hmdInfo[val.type] = {
          createTime: helper.getFormattedDate(currentDataObj.taskCreateDttm, 'local'),
          responseTime: helper.getFormattedDate(currentDataObj.taskResponseDttm, 'local'),
          result: dataResult
        };
      }
    })

    if (hmdInfo.yara.result) {
      hmdInfo.yara.count = Number(hmdInfo.yara.result.length);
    }

    if (hmdInfo.yaraScanFile.result) {
      hmdInfo.yaraScanFile.count = Number(hmdInfo.yaraScanFile.result.length);
    }

    if (hmdInfo.malware.result) {
      hmdInfo.malware.count = Number(hmdInfo.malware.result.length);

      hmdInfo.malware.fields = {};
      malwareFieldsArr.forEach(tempData => {
        hmdInfo.malware.fields[tempData] = {
          label: f(`malwareFields.${tempData}`),
          sortable: true,
          className: this.getFieldName(tempData),
          formatter: (value, allValue) => {
            if (tempData === '_FileInfo._Filepath') {
              if (value.length > 25) {
                const newValue = value.substr(0, 25) + '...';
                return &lt;span title={value}>{newValue}&lt;/span>
              } else {
                return &lt;span>{value}&lt;/span>
              }
            }
            if (tempData === '_FileInfo._HashValues._MD5') {
              if (value.length > 15) {
                const newValue = value.substr(0, 15) + '...';
                return &lt;span title={value}>{newValue}&lt;/span>
              } else {
                return &lt;span>{value}&lt;/span>
              }
            }
            if (tempData === '_FileInfo._Filesize') {
              value = value + ' KB';
            }
            if (tempData === '_IsPE' || tempData === '_IsPEextension' || tempData === '_IsVerifyTrust') {
              let styleStatus = '';

              if (value) {
                styleStatus = '#22ac38';
                value = 'True';
              } else {
                styleStatus = '#d0021b';
                value = 'False';
              }

              return &lt;span style={{color : styleStatus}}>{value}&lt;/span>
            }
            return &lt;span>{value}&lt;/span>
          }
        };
      })
    }

    if (hmdInfo.gcb.result) {
      hmdInfo.gcb.filteredResult = _.filter(hmdInfo.gcb.result, ['_CompareResult', 'true']);

      hmdInfo.gcb.fields = {};
      gcbFieldsArr.forEach(tempData => {
        hmdInfo.gcb.fields[tempData] = {
          label: f(`gcbFields.${tempData}`),
          sortable: true,
          className: 'gcb' + tempData,
          formatter: (value, allValue) => {
            if (tempData === '_CceId') {
              return &lt;span>{value}&lt;/span>
            }
            if (tempData === '_OriginalKey') {
              let content = value;

              if (locale === 'zh' &amp;&amp; allValue['_PolicyName_zh-tw']) {
                content = allValue['_PolicyName_zh-tw'];
              } else if (locale === 'en' &amp;&amp; allValue['_PolicyName_en']) {
                content = allValue['_PolicyName_en'];
              }

              if (content.length > 70) {
                const newValue = content.substr(0, 70) + '...';
                return &lt;span title={content}>{newValue}&lt;/span>
              } else {
                return &lt;span>{content}&lt;/span>
              }
            }
            if (tempData === '_Type') {
              return &lt;span>{value}&lt;/span>
            }
            if (tempData === '_CompareResult') {
              let styleStatus = '';
              let tooltip = '';

              if (value === 'true') {
                styleStatus = '#22ac38';
                value = 'Pass';
              } else if (value === 'false') {
                styleStatus = '#d0021b';
                value = 'Fail';
              }

              tooltip += 'GPO Value: ' + (allValue._GpoValue || 'N/A');
              tooltip += ' / GCB Value: ' + (allValue._GcbValue || 'N/A');

              return &lt;span style={{color : styleStatus}} title={tooltip}>{value}&lt;/span>
            }
          }
        };
      })
    }

    return (
      &lt;div className='scan-info'>
        &lt;ButtonGroup
          className='left'
          list={buttonGroupList}
          onChange={this.toggleScanType}
          value={activeTab} />

        &lt;div className='info-content'>
          &lt;div>
            &lt;div className='info'>
              &lt;div className='last-update'>
                &lt;span>{t('network-inventory.txt-createTime')}: {hmdInfo[activeTab].createTime || NOT_AVAILABLE}&lt;/span>
                &lt;span>{t('network-inventory.txt-responseTime')}: {hmdInfo[activeTab].responseTime || NOT_AVAILABLE}&lt;/span>
              &lt;/div>
              {this.getSuspiciousFileCount(hmdInfo)} {/*For Scan Process, Yara and AI*/}
              {this.getPassTotalCount(hmdInfo)} {/*For GCB*/}
              {this.getTriggerBtn(hmdInfo)} {/*For all*/}
            &lt;/div>
            {this.getScanContent(hmdInfo)} {/*For Scan Process, Scan File(Yara) and IR*/}
            {this.getTableContent(hmdInfo)} {/*For Scan File (AI) and GCB*/}
          &lt;/div>
        &lt;/div>
      &lt;/div>
    )
  }
}

HMDscanInfo.propTypes = {
  baseUrl: PropTypes.string.isRequired,
  contextRoot: PropTypes.string.isRequired,
  language: PropTypes.string.isRequired,
  locale: PropTypes.string.isRequired,
  currentDeviceData: PropTypes.object.isRequired,
  toggleSelectionIR: PropTypes.func.isRequired,
  triggerTask: PropTypes.func.isRequired
};

const HocHMDscanInfo = withLocale(HMDscanInfo);
export { HMDscanInfo, HocHMDscanInfo };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountEdit.html">AccountEdit</a></li><li><a href="AccountList.html">AccountList</a></li><li><a href="Alert.html">Alert</a></li><li><a href="AlertController.html">AlertController</a></li><li><a href="AlertDetails.html">AlertDetails</a></li><li><a href="AutoSettings.html">AutoSettings</a></li><li><a href="ChartContent.html">ChartContent</a></li><li><a href="Config.html">Config</a></li><li><a href="Connections.html">Connections</a></li><li><a href="DashboardMaps.html">DashboardMaps</a></li><li><a href="DashboardStats.html">DashboardStats</a></li><li><a href="DataChart.html">DataChart</a></li><li><a href="Edge.html">Edge</a></li><li><a href="EditHosts.html">EditHosts</a></li><li><a href="File.html">File</a></li><li><a href="FileUpload.html">FileUpload</a></li><li><a href="FilterContent.html">FilterContent</a></li><li><a href="FilterInput.html">FilterInput</a></li><li><a href="FloorMap.html">FloorMap</a></li><li><a href="Header.html">Header</a></li><li><a href="HMDscanInfo.html">HMDscanInfo</a></li><li><a href="IpRange.html">IpRange</a></li><li><a href="IrSelections.html">IrSelections</a></li><li><a href="Login.html">Login</a></li><li><a href="Manage.html">Manage</a></li><li><a href="MarkContent.html">MarkContent</a></li><li><a href="MarkInput.html">MarkInput</a></li><li><a href="Netflow.html">Netflow</a></li><li><a href="NetworkInventory.html">NetworkInventory</a></li><li><a href="NetworkMap.html">NetworkMap</a></li><li><a href="NetworkOwner.html">NetworkOwner</a></li><li><a href="Notifications.html">Notifications</a></li><li><a href="Pagination.html">Pagination</a></li><li><a href="PrivateDetails.html">PrivateDetails</a></li><li><a href="PrivilegeAdd.html">PrivilegeAdd</a></li><li><a href="PrivilegeEdit.html">PrivilegeEdit</a></li><li><a href="QueryOpenSave.html">QueryOpenSave</a></li><li><a href="Relationships.html">Relationships</a></li><li><a href="ResetPwd.html">ResetPwd</a></li><li><a href="Roles.html">Roles</a></li><li><a href="Scanner.html">Scanner</a></li><li><a href="SearchFilter.html">SearchFilter</a></li><li><a href="SearchMark.html">SearchMark</a></li><li><a href="SearchOptions.html">SearchOptions</a></li><li><a href="SortableItem.html">SortableItem</a></li><li><a href="SortableList.html">SortableList</a></li><li><a href="Status.html">Status</a></li><li><a href="Syslog.html">Syslog</a></li><li><a href="SyslogController.html">SyslogController</a></li><li><a href="TableCell.html">TableCell</a></li><li><a href="TableContent.html">TableContent</a></li><li><a href="ThreatIntelligence.html">ThreatIntelligence</a></li><li><a href="Tree.html">Tree</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Dec 05 2019 12:09:38 GMT+0800 (台北標準時間)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
